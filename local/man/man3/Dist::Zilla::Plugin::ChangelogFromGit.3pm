.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Dist::Zilla::Plugin::ChangelogFromGit 3"
.TH Dist::Zilla::Plugin::ChangelogFromGit 3 "2013-08-12" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dist::Zilla::Plugin::ChangelogFromGit \- Write a Changes file from a project's git log.
.SH "VERSION"
.IX Header "VERSION"
version 0.015
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Here's an example dist.ini section showing all the current options and
their default values.
.PP
.Vb 6
\&        [ChangelogFromGit]
\&        max_age     = 365
\&        tag_regexp  = ^v(\ed+\e.\ed+)$
\&        file_name   = CHANGES
\&        wrap_column = 74
\&        debug       = 0
.Ve
.PP
Variables don't need to be set to their default values.  This is
equivalent to the configuration above.
.PP
.Vb 1
\&        [ChangelogFromGit]
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This Dist::Zilla plugin turns a project's git commit log into a
change log file.  It's better than simply running `git log > CHANGES`
in at least two ways.  First, it understands release tags, and it uses
them to group changes by release.  Second, it reformats the changes to
make them easier to read.  And third, subclasses can change some or
all of the reformatting to make change logs even easier to read.
.PP
See this project's \s-1CHANGES\s0 file for sample output.  Yes, this project
uses itself to generate its own change log.  Why not?
.SH "CONFIGURATION / PUBLIC ATTRIBUTES"
.IX Header "CONFIGURATION / PUBLIC ATTRIBUTES"
As seen in the \*(L"\s-1SYNOPSIS\*(R"\s0, this plugin has a number of public
attributes that may be set using dist.ini configuration variables.
.SS "max_age = \s-1INTEGER\s0"
.IX Subsection "max_age = INTEGER"
The \f(CW\*(C`max_age\*(C'\fR configuration variable limits the age of releases to be
included in the change log.  The default is to include releases going
back about a year.  To include about two years, one would double the
default value:
.PP
.Vb 2
\&        [ChangelogFromGit]
\&        max_age = 730
.Ve
.PP
\&\f(CW\*(C`max_age\*(C'\fR is intended to limit the size of change logs for large,
long-term projects that don't want to include the entire, huge commit
history in every release.
.SS "tag_regexp = \s-1REGULAR_EXPRESSION\s0"
.IX Subsection "tag_regexp = REGULAR_EXPRESSION"
\&\f(CW\*(C`tag_regexp\*(C'\fR sets the regular expression that detects which tags mark
releases.  It also extracts the version numbers from these tags using
a regular expression back reference or capture.  For example, a
project's release tags might match 'release\-1.000', 'release\-1.001',
etc.  This \f(CW\*(C`tag_regexp\*(C'\fR will find them and extract their versions.
.PP
.Vb 2
\&        [ChangelogFromGit]
\&        tag_regexp = ^release\-(\ed+.*)$
.Ve
.PP
There is no single standard format for release tags.  \f(CW\*(C`tag_regexp\*(C'\fR
defaults to the author's convention.  It will most likely need to be
changed.
.SS "file_name = \s-1STRING\s0"
.IX Subsection "file_name = STRING"
\&\f(CW\*(C`file_name\*(C'\fR sets the name of the change log that will be written.  It
defaults to \*(L"\s-1CHANGES\*(R",\s0 but some people may prefer \*(L"Changes\*(R",
\&\*(L"Changelog\*(R", or something else.
.PP
.Vb 2
\&        [ChangelogFromGit]
\&        file_name = Changes
.Ve
.SS "wrap_column = \s-1INTEGER\s0"
.IX Subsection "wrap_column = INTEGER"
Different contributors tend to use different commit message formats,
which can be disconcerting to the typographically aware release
engineer.  \f(CW\*(C`wrap_column\*(C'\fR sets the line length to which all commit
messages will be re-wrapped.  It's 74 columns by default.  If this is
too short:
.PP
.Vb 2
\&        [ChangelogFromGit]
\&        wrap_column = 78
.Ve
.SS "debug = \s-1BOOLEAN\s0"
.IX Subsection "debug = BOOLEAN"
Developers are people, too.  The \f(CW\*(C`debug\*(C'\fR option enables some noisy
runtime tracing on \s-1STDERR.\s0
.PP
.Vb 2
\&        [ChangelogFromGit]
\&        debug = 1
.Ve
.SS "exclude_message = \s-1REGULAR_EXPRESSION\s0"
.IX Subsection "exclude_message = REGULAR_EXPRESSION"
\&\f(CW\*(C`exclude_message\*(C'\fR sets a regular expression which discards matching
commit messages.  This provides a way to exclude commit messages such
as 'forgot to include file X' or 'typo'.  The regular expression is
case sensitive.
.PP
.Vb 2
\&        [ChangelogFromGit]
\&        exclude_message = ^(forgot|typo)
.Ve
.PP
\&\f(CW\*(C`include_message\*(C'\fR can be used to do the opposite: exclude all changes
except ones that match a regular expression.  Using both at once is
liable to generate empty change logs.
.SS "include_message = \s-1REGULAR_EXPRESSION\s0"
.IX Subsection "include_message = REGULAR_EXPRESSION"
\&\f(CW\*(C`include_message\*(C'\fR does the opposite of \f(CW\*(C`exclude_message\*(C'\fR: it sets a
regular expression which commit messages must match in order to be
included in the Changes file.  This means that when making a commit
with a relevant message, you must include text that matches the
regular expression pattern to have it included in the Changes file.
All other commit messages are ignored.
.PP
The regular expression is case sensitive.
.PP
.Vb 2
\&        [ChangelogFromGit]
\&        include_message = ^Major
.Ve
.PP
Using both \f(CW\*(C`include_message\*(C'\fR and \f(CW\*(C`exclude_message\*(C'\fR at the same time
will most likely result in empty change logs.
.SH "HOW IT WORKS"
.IX Header "HOW IT WORKS"
Dist::Zilla::ChangelogFromGit collects the tags matching \f(CW\*(C`tag_regexp\*(C'\fR
that are not older than \f(CW\*(C`max_age\*(C'\fR days old.  These are used to
identify and time stamp releases.  Each release is encapsulated into a
Software::Release object.
.PP
Git::Repository::Log::Iterator is used to collect the changes prior to
each release but after the previous release.  Change log entries are
added to their respective Software::Release objects.
.PP
\&\f(CW\*(C`$self\->render_changelog()\*(C'\fR is called after all the relevant
releases and changes are known.  It must return the rendered change
log as a string.  That string will be used as the content for a
Dist::Zilla::File::InMemory object representing the new change log.
.SH "SUBCLASSING FOR NEW FORMATS"
.IX Header "SUBCLASSING FOR NEW FORMATS"
Dist::Zilla::ChangelogFromGit implement about a dozen methods to
render the various parts of a change log.  Subclasses may override or
augment any or all of these methods to alter the way change logs are
rendered.
.PP
All methods beginning with \*(L"render\*(R" return strings that will be
incorporated into the change log.  Methods that will not contribute to
the change log must return empty strings.
.SS "Rendering Entire Change Logs"
.IX Subsection "Rendering Entire Change Logs"
Methods beginning with \*(L"render_changelog\*(R" receive no parameters other
than \f(CW$self\fR.  Everything they need to know about the change log is
included in the object's attributes: \f(CW\*(C`wrap_column\*(C'\fR, \f(CW\*(C`releases\*(C'\fR,
\&\f(CW\*(C`skipped_release_count\*(C'\fR, \f(CW\*(C`earliest_date\*(C'\fR.
.PP
\fIrender_changelog\fR
.IX Subsection "render_changelog"
.PP
\&\fIrender_changelog()\fR returns the text of the entire change log.  By
default, the change log is built from a header, zero or more releases,
and a footer.
.PP
.Vb 8
\&        sub render_changelog {
\&                my $self = shift();
\&                return(
\&                        $self\->render_changelog_header() .
\&                        $self\->render_changelog_releases() .
\&                        $self\->render_changelog_footer()
\&                );
\&        }
.Ve
.PP
\fIrender_changelog_header\fR
.IX Subsection "render_changelog_header"
.PP
\&\fIrender_changelog_header()\fR renders some text that introduces the reader
to the change log.
.PP
.Vb 8
\&        sub render_changelog_header {
\&                my $self = shift();
\&                my $header = (
\&                        "Changes from " . $self\->format_datetime($self\->earliest_date()) .
\&                        " to present."
\&                );
\&                return $self\->surround_line("=", $header) . "\en";
\&        }
.Ve
.PP
\fIrender_changelog_releases\fR
.IX Subsection "render_changelog_releases"
.PP
\&\fIrender_changelog_releases()\fR iterates through each release, calling
upon \f(CW$self\fR to render them one at a time.
.PP
.Vb 2
\&        sub render_changelog_releases {
\&                my $self = shift();
\&
\&                my $changelog = \*(Aq\*(Aq;
\&
\&                RELEASE: foreach my $release (reverse $self\->all_releases()) {
\&                        next RELEASE if $release\->has_no_changes();
\&                        $changelog .= $self\->render_release($release);
\&                }
\&
\&                return $changelog;
\&        }
.Ve
.PP
\fIrender_changelog_footer\fR
.IX Subsection "render_changelog_footer"
.PP
\&\fIrender_changelog_footer()\fR tells the reader that the change log is
over.  Normally the end of the file is sufficient warning, but a
truncated change log is friendlier when the reader knows what they're
missing.
.PP
.Vb 2
\&        sub render_changelog_footer {
\&                my $self = shift();
\&
\&                my $skipped_count = $self\->skipped_release_count();
\&
\&                my $changelog_footer;
\&
\&                if ($skipped_count) {
\&                        my $releases = "release" . ($skipped_count == 1 ? "" : "s");
\&                        $changelog_footer = (
\&                                "Plus $skipped_count $releases after " .
\&                                $self\->format_datetime($self\->earliest_date()) . \*(Aq.\*(Aq
\&                        );
\&                }
\&                else {
\&                        $changelog_footer = "End of releases.";
\&                }
\&
\&                return $self\->surround_line("=", $changelog_footer);
\&        }
.Ve
.SS "Rendering Individual Releases"
.IX Subsection "Rendering Individual Releases"
Methods beginning with \*(L"render_release\*(R" receive \f(CW$self\fR plus one
additional parameter: a Software::Release object encapsulating the
release and its changes.  See Software::Release to learn the
information that object encapsulates.
.PP
\fIrender_release\fR
.IX Subsection "render_release"
.PP
\&\fIrender_release()\fR is called upon to render a single release.  In the
change log, a release consists of a header, one or more changes, and a
footer.
.PP
.Vb 8
\&        sub render_release {
\&                my ($self, $release) = @_;
\&                return(
\&                        $self\->render_release_header($release) .
\&                        $self\->render_release_changes($release) .
\&                        $self\->render_release_footer($release)
\&                );
\&        }
.Ve
.PP
\fIrender_release_header\fR
.IX Subsection "render_release_header"
.PP
\&\fIrender_release_header()\fR introduces a release.
.PP
.Vb 2
\&        sub render_release_header {
\&                my ($self, $release) = @_;
\&
\&                my $version = $release\->version();
\&                $version = $self\->zilla()\->version() if $version eq \*(AqHEAD\*(Aq;
\&
\&                my $release_header = (
\&                        $self\->format_release_tag($release\->version()) . \*(Aq at \*(Aq .
\&                        $self\->format_datetime($release\->date())
\&                );
\&
\&                return $self\->surround_line("\-", $release_header) . "\en";
\&        }
.Ve
.PP
\fIrender_release_changes\fR
.IX Subsection "render_release_changes"
.PP
\&\fIrender_release_changes()\fR iterates through the changes associated with
each Software::Release object.  It calls upon \fIrender_change()\fR to
render each change.
.PP
.Vb 2
\&        sub render_release_changes {
\&                my ($self, $release) = @_;
\&
\&                my $changelog = \*(Aq\*(Aq;
\&
\&                foreach my $change (@{ $release\->changes() }) {
\&                        $changelog .= $self\->render_change($release, $change);
\&                }
\&
\&                return $changelog;
\&        }
.Ve
.PP
\fIrender_release_footer\fR
.IX Subsection "render_release_footer"
.PP
\&\fIrender_release_footer()\fR may be used to divide releases.  It's not used
	by default, but it's implemented for completeness.
.PP
.Vb 4
\&        sub render_release_footer {
\&                my ($self, $release) = @_;
\&                return \*(Aq\*(Aq;
\&        }
.Ve
.SS "Rendering Individual Changes"
.IX Subsection "Rendering Individual Changes"
Methods beginning with \*(L"render_change\*(R" receive two parameters in
addition to \f(CW$self:\fR a Software::Release object encapsulating the
release containing this change, and a Software::Release::Change
object encapsulating the change itself.
.PP
\fIrender_change\fR
.IX Subsection "render_change"
.PP
\&\fIrender_change()\fR renders a single change, which is the catenation of a
change header, change message, and footer.
.PP
.Vb 8
\&        sub render_change {
\&                my ($self, $release, $change) = @_;
\&                return(
\&                        $self\->render_change_header($release, $change) .
\&                        $self\->render_change_message($release, $change) .
\&                        $self\->render_change_footer($release, $change)
\&                );
\&        }
.Ve
.PP
\fIrender_change_header\fR
.IX Subsection "render_change_header"
.PP
\&\fIrender_change_header()\fR generally renders identifying information about
each change.  This method's responsibility is to produce useful
information in a pleasant format.
.PP
.Vb 2
\&        sub render_change_header {
\&                my ($self, $release, $change) = @_;
\&
\&                use Text::Wrap qw(fill);
\&
\&                local $Text::Wrap::huge    = \*(Aqwrap\*(Aq;
\&                local $Text::Wrap::columns = $self\->wrap_column();
\&
\&                my @indent = ("  ", "  ");
\&
\&                return(
\&                        fill(
\&                                "  ", "  ",
\&                                \*(AqChange: \*(Aq . $change\->change_id
\&                        ) .
\&                        "\en" .
\&                        fill(
\&                                "  ", "  ",
\&                                \*(AqAuthor: \*(Aq . $change\->author_name.\*(Aq <\*(Aq.$change\->author_email.\*(Aq>\*(Aq
\&                        ) .
\&                        "\en" .
\&                        fill(
\&                                "  ", "  ",
\&                                \*(AqDate  : \*(Aq . $self\->format_datetime($change\->date())
\&                        ) .
\&                        "\en\en"
\&                );
\&        }
.Ve
.PP
\fIrender_change_message\fR
.IX Subsection "render_change_message"
.PP
\&\fIrender_change_message()\fR renders the commit message for the change log.
.PP
.Vb 2
\&        sub render_change_message {
\&                my ($self, $release, $change) = @_;
\&
\&                use Text::Wrap qw(fill);
\&
\&                return \*(Aq\*(Aq if $change\->description() =~ /^\es/;
\&
\&                local $Text::Wrap::huge = \*(Aqwrap\*(Aq;
\&                local $Text::Wrap::columns = $self\->wrap_column();
\&
\&                return fill("    ", "    ", $change\->description) . "\en";
\&        }
.Ve
.PP
\fIrender_change_footer\fR
.IX Subsection "render_change_footer"
.PP
\&\fIrender_change_footer()\fR returns summary and/or divider text for the
change.
.PP
.Vb 4
\&        sub render_change_footer {
\&                my ($self, $release, $change) = @_;
\&                return "\en";
\&        }
.Ve
.SS "Formatting Data"
.IX Subsection "Formatting Data"
Dist::Zilla::Plugin::ChangelogFromGit includes a few methods to
consistently format certain data types.
.PP
\fIformat_datetime\fR
.IX Subsection "format_datetime"
.PP
\&\fIformat_datetime()\fR converts the DateTime objects used internally
into friendly, human readable dates and times for the change log.
.PP
.Vb 4
\&        sub format_datetime {
\&                my ($self, $datetime) = @_;
\&                return $datetime\->strftime("%F %T %z");
\&        }
.Ve
.PP
\fIformat_release_tag\fR
.IX Subsection "format_release_tag"
.PP
\&\fIformat_release_tag()\fR turns potentially cryptic release tags into
friendly version numbers for the change log.  By default, it also
replaces the '\s-1HEAD\s0' version with the current version being released.
This accommodates release managers who prefer to tag their
distributions after releasing them.
.PP
.Vb 2
\&        sub format_release_tag {
\&                my ($self, $release_tag) = @_;
\&
\&                return \*(Aqversion \*(Aq . $self\->zilla()\->version() if $release_tag eq \*(AqHEAD\*(Aq;
\&
\&                my $tag_regexp = $self\->tag_regexp();
\&                $release_tag =~ s/$tag_regexp/version $1/;
\&                return $release_tag;
\&        }
.Ve
.PP
\fIsurround_line\fR
.IX Subsection "surround_line"
.PP
\&\fIsurround_line()\fR will surround a line of output with lines of dashes or
other characters.  It's used to help heading stand out.  This method
takes two strings: a character (or string) that will repeat to fill
surrounding lines, and the line to surround.  It returns a three-line
string: the original line preceded and followed by surrounding lines.
.PP
.Vb 2
\&        sub surround_line {
\&                my ($self, $character, $string) = @_;
\&
\&                my $surrounder = substr(
\&                        ($character x (length($string) / length($character) + 1)),
\&                        0,
\&                        length($string)
\&                );
\&
\&                return "$surrounder\en$string\en$surrounder\en";
\&        }
.Ve
.SH "INTERNAL ATTRIBUTES"
.IX Header "INTERNAL ATTRIBUTES"
Dist::Zilla::Plugin::ChangelogFromGit accumulates useful information
into a few internal attributes.  These aren't intended to be
configured by dist.ini, but they are important for rendering change
logs.
.SS "earliest_date"
.IX Subsection "earliest_date"
\&\fIearliest_date()\fR contains a DateTime object that represents the date
and time of the earliest release to include.  It's initialized as
midnight for the date \fImax_age()\fR days ago.
.SS "releases"
.IX Subsection "releases"
\&\fIreleases()\fR contains an array reference of Software::Release objects
that will be included in the change log.
.PP
\fIall_releases\fR
.IX Subsection "all_releases"
.PP
\&\fIall_releases()\fR returns a list of the Software::Release objects that
should be included in the change log.  It's a friendly equivalent of
\&\f(CW\*(C`@{$self\->releases()}\*(C'\fR.
.PP
\fIget_release\fR
.IX Subsection "get_release"
.PP
\&\fIget_release()\fR returns a single release by index.  The first release
in the change log may be retrieved as \f(CW\*(C`$self\->get_release(0)\*(C'\fR.
.PP
\fIreleae_count\fR
.IX Subsection "releae_count"
.PP
\&\fIrelease_count()\fR returns the number of Software::Release objects in the
\&\*(L"releases\*(R" attribute.
.PP
\fIsort_releases\fR
.IX Subsection "sort_releases"
.PP
\&\fIsort_releases()\fR sorts the Software::Release objects in the \fIreleases()\fR
using some comparator.  For example, to sort releases in time order:
.PP
.Vb 5
\&        $self\->sort_releases(
\&                sub {
\&                        DateTime\->compare( $_[0]\->date(), $_[1]\->date() )
\&                }
\&        );
.Ve
.SS "skipped_release_count"
.IX Subsection "skipped_release_count"
\&\fIskipped_release_count()\fR contains the number of releases truncated by
\&\fImax_age()\fR.  The default \fIrender_changelog_footer()\fR uses it to display
the number of changes that have been omitted from the log.
.SH "Subversion and CVS"
.IX Header "Subversion and CVS"
This plugin is almost entirely a copy-and-paste port of a command-line
tool I wrote a while ago.  I also have tools to generate similar
change logs for \s-1CVS\s0 and Subversion projects.  I'm happy to contribute
that code to people interested in creating Dist::Zilla plugins for
other version control systems.
.PP
We should also consider abstracting the formatting code out to a role
so that it can be shared among different plugins.
.SH "BUGS"
.IX Header "BUGS"
The documentation includes copies of the renderer methods.  This
increases technical debt, since changes to those methods must also be
copied into the documentation.  Rocco needs to finish Pod::Plexus
and use it here to simplify maintenance of the documentation.
.PP
Collecting all releases and changes before rendering the change log
may be considered harmful for extremely large projects.  If someone
thinks they can generate change logs incrementally, their assistance
would be appreciated.
.SH "AUTHORS"
.IX Header "AUTHORS"
Rocco Caputo <rcaputo@cpan.org> \- Initial release, and ongoing
management and maintenance.
.PP
Cory G. Watson <gphat@cpan.org> \- Made formatting extensible and
overridable.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2010\-2013 by Rocco Caputo.
.PP
This is free software; you may redistribute it and/or modify it under
the same terms as the Perl 5 programming language itself.
