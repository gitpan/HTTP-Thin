.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::MVP::Slicer 3"
.TH Config::MVP::Slicer 3 "2012-06-18" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::MVP::Slicer \- Extract embedded plugin config from parent config
.SH "VERSION"
.IX Header "VERSION"
version 0.302
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  my $slicer = Config::MVP::Slicer\->new({
\&    config => $parent\->config,
\&  });
\&
\&  # extract a hashref from the parent config without modifying the plugin
\&  my $plugin_config = $slicer\->slice($plugin);
\&
\&  # from plugin bundles:
\&  my $plugin_spec = [\*(AqName\*(Aq, \*(AqPackage::Name\*(Aq, {default => \*(Aqconfig\*(Aq}];
\&  # update the hashref
\&  $slicer\->merge($plugin_spec);
\&
\&  # with object instances:
\&  my $plugger = App::Plugin::Plugger\->new({some => \*(Aqconfig\*(Aq});
\&  # update \*(Aqrw\*(Aq attributes
\&  $slicer\->merge($plugger);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This can be used to extract embedded configurations for other plugins
out of larger (parent) configurations.
.PP
A example where this can be useful is plugin bundles
(see Config::MVP::Assembler::WithBundles).
.PP
A bundle loads other plugins with a default configuration
that works most of the time, but sometimes you wish you could
customize the configuration for one of those plugins
without having to remove the plugin from the bundle
and re-specify it separately.
.PP
.Vb 3
\&  # mvp config file
\&  [@MyBundle]
\&  Other::Plugin.setting = new value
.Ve
.PP
Now you can accept customizations to plugins into your
bundle config and separate them out using this module.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "config"
.IX Subsection "config"
This is the main/parent configuration hashref
that contains embedded plugin configurations.
.SS "match_name"
.IX Subsection "match_name"
This is coderef that determines if a configuration line
matches a plugin's name.
.PP
It can be customized by passing an alternate subroutine reference
to the constructor.
.PP
The sub will receive two arguments:
.IP "\(bu" 4
The plugin name portion of the configuration line
.IP "\(bu" 4
The name of the plugin being worked on (provided to \*(L"slice\*(R", for instance).
.PP
The default returns true if the current plugin name matches
the name from the config line
regardless of any leading \*(L"@Bundle/\*(R" prefixes in the plugin name
(as this is a common convention for bundles).
.PP
Obviously if the \*(L"@Bundle/\*(R" prefix is specified in the configuration
then it is required to be there for the default sub to match
(but multiple other \*(L"@Bundle/\*(R" prefixes will be allowed before it).
.PP
.Vb 1
\&  # configuration line: "Foo.attr = value"
\&
\&  $slicer\->match_name("Foo", "Foo");            # true
\&  $slicer\->match_name("Foo", "@Bar/Foo");       # true
\&  $slicer\->match_name("Foo", "Bar");            # false
\&
\&  # configuration line: "@Bar/Foo.attr = value"
\&
\&  $slicer\->match_name("@Bar/Foo", "Foo");           # false
\&  $slicer\->match_name("@Bar/Foo", "@Bar/Foo");      # true
\&  $slicer\->match_name("@Bar/Foo", "@Baz/@Bar/Foo"); # true
\&  $slicer\->match_name("@Bar/Foo", "@Baz/Foo");      # false
.Ve
.PP
Subclasses can define \f(CW\*(C`_build_match_name\*(C'\fR
(which should return a \f(CW\*(C`sub\*(C'\fR) to overwrite the default.
.SS "match_package"
.IX Subsection "match_package"
This works like \*(L"match_name\*(R"
except that the configuration line is compared
to the plugin's package (class).
.PP
The default returns true if the two values are equal and false otherwise.
.PP
If you want to match by package rather than name
and you expand packages with (for example) a string prefix
you may need to set this to something like:
.PP
.Vb 1
\&  match_package => sub { rewrite_prefix($_[0]) eq $_[1] }
.Ve
.PP
Subclasses can define \f(CW\*(C`_build_match_package\*(C'\fR
(which should return a \f(CW\*(C`sub\*(C'\fR) to overwrite the default.
.SS "prefix"
.IX Subsection "prefix"
Regular expression that should match at the beginning of a key
before the module name and attribute:
.PP
.Vb 2
\&  # prefix => \*(Aqdynamic\e.\*(Aq
\&  # { \*(Aqdynamic.Module::Name.attr\*(Aq => \*(Aqvalue\*(Aq }
.Ve
.PP
This can be a string or a compiled regular expression (\f(CW\*(C`qr//\*(C'\fR).
.PP
The default is no prefix (empty string \f(CW\*(Aq\*(Aq\fR).
.SS "separator"
.IX Subsection "separator"
A regular expression that will capture
the package name in \f(CW$1\fR and
the attribute name in \f(CW$2\fR.
.PP
The default (\f(CW\*(C`(.+?)\e.(.+?)\*(C'\fR)
separates plugin name from attribute name with a dot:
.PP
.Vb 2
\&  \*(AqModule::Name.attribute\*(Aq
\&  \*(Aq\-Plugin.attr\*(Aq
.Ve
.PP
\&\fB\s-1NOTE\s0\fR: The regexp should \fBnot\fR be anchored since \*(L"separator_regexp\*(R"
uses it as the middle piece of a larger regexp
(to add \*(L"prefix\*(R" and the possible array bracket suffix).
Also beware of using a regexp that greedily matches the array bracket suffix
as that can confuse things as well.
.SH "METHODS"
.IX Header "METHODS"
.SS "separator_regexp"
.IX Subsection "separator_regexp"
Returns a compiled regular expression (\f(CW\*(C`qr//\*(C'\fR)
combining \*(L"prefix\*(R", \*(L"separator\*(R",
and the possible trailing array specification (\f(CW\*(C`\e[.*?\e]\*(C'\fR).
.SS "slice"
.IX Subsection "slice"
.Vb 1
\&  $slicer\->slice($plugin);
.Ve
.PP
Return a hashref of the config arguments for the plugin
determined by \f(CW$plugin\fR.
.PP
This is a slice of the \*(L"config\*(R" attribute
appropriate for the plugin passed to the method.
.PP
Starting with a config hashref of:
.PP
.Vb 5
\&  {
\&    \*(AqAPlug:attr1\*(Aq   => \*(Aqvalue1\*(Aq,
\&    \*(AqAPlug:second\*(Aq  => \*(Aq2nd\*(Aq,
\&    \*(AqOtherPlug:attr => \*(Aq0\*(Aq
\&  }
.Ve
.PP
Passing a plugin instance of \f(CW\*(AqAPlug\*(Aq\fR
(or an arrayref of \f(CW\*(C`[\*(AqAPlug\*(Aq, \*(AqFull::Package::APlug\*(Aq, {}]\*(C'\fR)
would return:
.PP
.Vb 4
\&  {
\&    \*(Aqattr1\*(Aq   => \*(Aqvalue1\*(Aq,
\&    \*(Aqsecond\*(Aq  => \*(Aq2nd\*(Aq
\&  }
.Ve
.SS "merge"
.IX Subsection "merge"
.Vb 1
\&  $slicer\->merge($plugin, \e%opts);
.Ve
.PP
Get the config slice (see \*(L"slice\*(R"),
then attempt to merge it into the plugin.
.PP
If \f(CW$plugin\fR is an arrayref the hashref will be modified.
If it is an object it's attributes should be writable (\f(CW\*(Aqrw\*(Aq\fR).
.PP
This will append to array references
if it was specified as an array
or if a preexisting value is an arrayref.
.PP
Returns the modified \f(CW$plugin\fR for convenience.
.PP
Possible options:
.IP "\(bu" 4
\&\f(CW\*(C`slice\*(C'\fR \- A hashref like that returned from \*(L"slice\*(R".  If not present, \*(L"slice\*(R" will be called.
.SS "plugin_info"
.IX Subsection "plugin_info"
.Vb 1
\&  $slicer\->plugin_info($plugin);
.Ve
.PP
Used by other methods to normalize the information about a plugin.
Returns a list of \f(CW\*(C`($name, $package, \e%config)\*(C'\fR.
.PP
If \f(CW$plugin\fR is an arrayref it will simply dereference it.
This can be useful for processing the results of plugin bundles.
.PP
If \f(CW$plugin\fR is an instance of a plugin that has a \f(CW\*(C`plugin_name\*(C'\fR
method it will construct the list from that method, \f(CW\*(C`ref\*(C'\fR,
and the instance itself.
.SH "CONFIGURATION SYNTAX"
.IX Header "CONFIGURATION SYNTAX"
Often configurations come from an \f(CW\*(C`ini\*(C'\fR file and look like this:
.PP
.Vb 2
\&  [PluginName]
\&  option = value
.Ve
.PP
This gets converted to a hashref:
.PP
.Vb 1
\&  PluginName\->new({ option => \*(Aqvalue\*(Aq });
.Ve
.PP
To embed configuration for other plugins:
.PP
.Vb 3
\&  [@BigBundle]
\&  bundle_option = value
\&  Bundled::Plugin.option = other value
.Ve
.PP
The simple 'bundle_option' attribute is for \f(CW@BigBundle\fR,
and the bundle can slice out the \f(CW\*(C`Bundled::Plugin\*(C'\fR configuration
and merge it in to that plugin's configuration.
.PP
Prefixes can be used (see \*(L"prefix\*(R").
In this example the prefix is set as \f(CW"plug."\fR.
.PP
.Vb 2
\&  [@Foo]
\&  plug.Bundled::Plugin.attr = value
.Ve
.PP
Due to limitations of this dynamic passing of unknown options
(otherwise known as a \fIhack\fR)
values that are arrays cannot be declared ahead of time by the bundle.
You can help out by specifying that an attribute should be an array:
.PP
.Vb 3
\&  [@Bar]
\&  Baz.quux[0] = part 1
\&  Baz.quux[1] = part 2
.Ve
.PP
This is required because each line will end up in a hashref:
.PP
.Vb 1
\&  { "quux[0]" => "part 1", "quxx[1]" => "part 2" }
.Ve
.PP
The subscripts inside the brackets are used for sorting but otherwise ignored.
The \*(L"slice\*(R" method will sort the keys (\fBalphabetically\fR) to produce:
.PP
.Vb 1
\&  { quux => ["part 1", "part 2"] }
.Ve
.PP
For simplicity the keys are sorted \fBalphabetically\fR
because \f(CW\*(C`quux[1.9]\*(C'\fR and \f(CW\*(C`quux[1.10]\*(C'\fR
probably won't sort the way you intended anyway,
so just keep things simple:
.PP
.Vb 9
\&  [@Bundle]
\&  Plug.attr[0] = part 1
\&  Plug.attr[1] = part 2
\&  Plug.other[09] = part 1
\&  Plug.other[10] = part 2
\&  Plug.alpha[a] = part 1
\&  Plug.alpha[b] = part 2
\&  Plug.alpha[bc] = part 3
\&  Plug.single[] = subscript not required; only used for sorting
.Ve
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Perldoc"
.IX Subsection "Perldoc"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&  perldoc Config::MVP::Slicer
.Ve
.SS "Websites"
.IX Subsection "Websites"
The following websites have more information about this module, and may be of help to you. As always,
in addition to those websites please use your favorite search engine to discover more resources.
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
The default \s-1CPAN\s0 search engine, useful to view \s-1POD\s0 in \s-1HTML\s0 format.
.Sp
<http://search.cpan.org/dist/Config\-MVP\-Slicer>
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's Bug Tracker
.Sp
The \s-1RT \s0( Request Tracker ) website is the default bug/issue tracking system for \s-1CPAN.\s0
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Config\-MVP\-Slicer>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
The \s-1CPAN\s0 Ratings is a website that allows community ratings and reviews of Perl modules.
.Sp
<http://cpanratings.perl.org/d/Config\-MVP\-Slicer>
.IP "\(bu" 4
\&\s-1CPAN\s0 Testers
.Sp
The \s-1CPAN\s0 Testers is a network of smokers who run automated tests on uploaded \s-1CPAN\s0 distributions.
.Sp
<http://www.cpantesters.org/distro/C/Config\-MVP\-Slicer>
.IP "\(bu" 4
\&\s-1CPAN\s0 Testers Matrix
.Sp
The \s-1CPAN\s0 Testers Matrix is a website that provides a visual overview of the test results for a distribution on various Perls/platforms.
.Sp
<http://matrix.cpantesters.org/?dist=Config\-MVP\-Slicer>
.IP "\(bu" 4
\&\s-1CPAN\s0 Testers Dependencies
.Sp
The \s-1CPAN\s0 Testers Dependencies is a website that shows a chart of the test results of all dependencies for a distribution.
.Sp
<http://deps.cpantesters.org/?module=Config::MVP::Slicer>
.SS "Bugs / Feature Requests"
.IX Subsection "Bugs / Feature Requests"
Please report any bugs or feature requests by email to \f(CW\*(C`bug\-config\-mvp\-slicer at rt.cpan.org\*(C'\fR, or through
the web interface at <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Config\-MVP\-Slicer>. You will be automatically notified of any
progress on the request by the system.
.SS "Source Code"
.IX Subsection "Source Code"
<https://github.com/rwstauner/Config\-MVP\-Slicer>
.PP
.Vb 1
\&  git clone https://github.com/rwstauner/Config\-MVP\-Slicer.git
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Randy Stauner <rwstauner@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2011 by Randy Stauner.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
