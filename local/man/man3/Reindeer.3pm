.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Reindeer 3"
.TH Reindeer 3 "2014-03-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Reindeer \- Moose with more antlers
.SH "VERSION"
.IX Header "VERSION"
This document describes version 0.017 of Reindeer \- released March 03, 2014 as part of Reindeer.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    # ta\-da!
\&    use Reindeer;
\&
\&    # ...is the same as:
\&    use Moose;
\&    use MooseX::MarkAsMethods autoclean => 1;
\&    use MooseX::AlwaysCoerce;
\&    use MooseX::AttributeShortcuts;
\&    # etc, etc, etc
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Like Moose?  Use MooseX::* extensions?  Maybe some MooseX::Types
libraries?  Hate that you have to use them in every.  Single.  Class.
.PP
Reindeer aims to resolve that :)  Reindeer _is_ Moose \*(-- it's just Moose with
a number of the more useful/popular extensions already applied.  Reindeer is a
drop-in replacement for your \*(L"use Moose\*(R" line, that behaves in the exact same
way... Just with more pointy antlers.
.SH "EARLY RELEASE!"
.IX Header "EARLY RELEASE!"
Be aware this package should be considered early release code.  While Moose
and all our incorporated extensions have their own classifications (generally
\&\s-1GA\s0 or \*(L"stable\*(R"), this bundling is still under active development, and more
extensions, features and the like may still be added.
.PP
That said, my goal here is to increase functionality, not decrease it.
.PP
When this package hits \s-1GA /\s0 stable, I'll set the release to be >= 1.000.
.SH "NEW CLASS METHODS"
.IX Header "NEW CLASS METHODS"
.SS "\fIwith_traits()\fP"
.IX Subsection "with_traits()"
This method allows you to easily compose a new class with additional traits:
.PP
.Vb 1
\&    my $foo = Bar\->with_traits(\*(AqStools\*(Aq, \*(AqNorm\*(Aq)\->new(beer => 1, tab => undef);
.Ve
.PP
(See also MooseX::Traits.)
.SH "NEW ATTRIBUTE OPTIONS"
.IX Header "NEW ATTRIBUTE OPTIONS"
Unless specified here, all options defined by Moose::Meta::Attribute
and Class::MOP::Attribute remain unchanged.
.PP
For the following, \*(L"$name\*(R" should be read as the attribute name; and the
various prefixes should be read using the defaults
.SS "coerce => 0"
.IX Subsection "coerce => 0"
Coercion is \s-1ENABLED\s0 by default; explicitly pass \*(L"coerce => 0\*(R" to disable.
.PP
(See also MooseX::AlwaysCoerce.)
.SS "lazy_require => 1"
.IX Subsection "lazy_require => 1"
The reader methods for all attributes with that option will throw an exception
unless a value for the attributes was provided earlier by a constructor
parameter or through a writer method.
.PP
(See also MooseX::LazyRequire.)
.SS "is => 'rwp'"
.IX Subsection "is => 'rwp'"
Specifying \f(CW\*(C`is => \*(Aqrwp\*(Aq\*(C'\fR will cause the following options to be set:
.PP
.Vb 2
\&    is     => \*(Aqro\*(Aq
\&    writer => "_set_$name"
.Ve
.SS "is => 'lazy'"
.IX Subsection "is => 'lazy'"
Specifying \f(CW\*(C`is => \*(Aqlazy\*(Aq\*(C'\fR will cause the following options to be set:
.PP
.Vb 3
\&    is       => \*(Aqro\*(Aq
\&    builder  => "_build_$name"
\&    lazy     => 1
.Ve
.PP
\&\fB\s-1NOTE:\s0\fR Since 0.009 we no longer set \f(CW\*(C`init_arg => undef\*(C'\fR if no \f(CW\*(C`init_arg\*(C'\fR
is explicitly provided.  This is a change made in parallel with Moo, based
on a large number of people surprised that lazy also made one's \f(CW\*(C`init_def\*(C'\fR
undefined.
.SS "is => 'lazy', default => ..."
.IX Subsection "is => 'lazy', default => ..."
Specifying \f(CW\*(C`is => \*(Aqlazy\*(Aq\*(C'\fR and a default will cause the following options to be
set:
.PP
.Vb 3
\&    is       => \*(Aqro\*(Aq
\&    lazy     => 1
\&    default  => ... # as provided
.Ve
.PP
That is, if you specify \f(CW\*(C`is => \*(Aqlazy\*(Aq\*(C'\fR and also provide a \f(CW\*(C`default\*(C'\fR, then
we won't try to set a builder, as well.
.SS "builder => 1"
.IX Subsection "builder => 1"
Specifying \f(CW\*(C`builder => 1\*(C'\fR will cause the following options to be set:
.PP
.Vb 1
\&    builder => "_build_$name"
.Ve
.SS "clearer => 1"
.IX Subsection "clearer => 1"
Specifying \f(CW\*(C`clearer => 1\*(C'\fR will cause the following options to be set:
.PP
.Vb 1
\&    clearer => "clear_$name"
.Ve
.PP
or, if your attribute name begins with an underscore:
.PP
.Vb 1
\&    clearer => "_clear$name"
.Ve
.PP
(that is, an attribute named \*(L"_foo\*(R" would get \*(L"_clear_foo\*(R")
.SS "predicate => 1"
.IX Subsection "predicate => 1"
Specifying \f(CW\*(C`predicate => 1\*(C'\fR will cause the following options to be set:
.PP
.Vb 1
\&    predicate => "has_$name"
.Ve
.PP
or, if your attribute name begins with an underscore:
.PP
.Vb 1
\&    predicate => "_has$name"
.Ve
.PP
(that is, an attribute named \*(L"_foo\*(R" would get \*(L"_has_foo\*(R")
.SS "trigger => 1"
.IX Subsection "trigger => 1"
Specifying \f(CW\*(C`trigger => 1\*(C'\fR will cause the attribute to be created with a trigger
that calls a named method in the class with the options passed to the trigger.
By default, the method name the trigger calls is the name of the attribute
prefixed with \*(L"_trigger_\*(R".
.PP
e.g., for an attribute named \*(L"foo\*(R" this would be equivalent to:
.PP
.Vb 1
\&    trigger => sub { shift\->_trigger_foo(@_) }
.Ve
.PP
For an attribute named \*(L"_foo\*(R":
.PP
.Vb 1
\&    trigger => sub { shift\->_trigger_\|_foo(@_) }
.Ve
.PP
This naming scheme, in which the trigger is always private, is the same as the
builder naming scheme (just with a different prefix).
.SS "builder => sub { ... }"
.IX Subsection "builder => sub { ... }"
Passing a coderef to builder will cause that coderef to be installed in the
class this attribute is associated with the name you'd expect, and
\&\f(CW\*(C`builder => 1\*(C'\fR to be set.
.PP
e.g., in your class,
.PP
.Vb 1
\&    has foo => (is => \*(Aqro\*(Aq, builder => sub { \*(Aqbar!\*(Aq });
.Ve
.PP
\&...is effectively the same as...
.PP
.Vb 2
\&    has foo => (is => \*(Aqro\*(Aq, builder => \*(Aq_build_foo\*(Aq);
\&    sub _build_foo { \*(Aqbar!\*(Aq }
.Ve
.SS "isa => ..., constraint => sub { ... }"
.IX Subsection "isa => ..., constraint => sub { ... }"
Specifying the constraint option with a coderef will cause a new subtype
constraint to be created, with the parent type being the type specified in the
\&\f(CW\*(C`isa\*(C'\fR option and the constraint being the coderef supplied here.
.PP
For example, only integers greater than 10 will pass this attribute's type
constraint:
.PP
.Vb 6
\&    # value must be an integer greater than 10 to pass the constraint
\&    has thinger => (
\&        isa        => \*(AqInt\*(Aq,
\&        constraint => sub { $_ > 10 },
\&        # ...
\&    );
.Ve
.PP
Note that if you supply a constraint, you must also provide an \f(CW\*(C`isa\*(C'\fR.
.SS "isa => ..., constraint => sub { ... }, coerce => 1"
.IX Subsection "isa => ..., constraint => sub { ... }, coerce => 1"
Supplying a constraint and asking for coercion will \*(L"Just Work\*(R", that is, any
coercions that the \f(CW\*(C`isa\*(C'\fR type has will still work.
.PP
For example, let's say that you're using the \f(CW\*(C`File\*(C'\fR type constraint from
MooseX::Types::Path::Class, and you want an additional constraint that the
file must exist:
.PP
.Vb 6
\&    has thinger => (
\&        is         => \*(Aqro\*(Aq,
\&        isa        => File,
\&        constraint => sub { !! $_\->stat },
\&        coerce     => 1,
\&    );
.Ve
.PP
\&\f(CW\*(C`thinger\*(C'\fR will correctly coerce the string \*(L"/etc/passwd\*(R" to a
\&\f(CW\*(C`Path::Class:File\*(C'\fR, and will only accept the coerced result as a value if
the file exists.
.SS "coerce => [ Type => sub { ...coerce... }, ... ]"
.IX Subsection "coerce => [ Type => sub { ...coerce... }, ... ]"
Specifying the coerce option with a hashref will cause a new subtype to be
created and used (just as with the constraint option, above), with the
specified coercions added to the list.  In the passed hashref, the keys are
Moose types (well, strings resolvable to Moose types), and the values are
coderefs that will coerce a given type to our type.
.PP
.Vb 8
\&    has bar => (
\&        is     => \*(Aqro\*(Aq,
\&        isa    => \*(AqStr\*(Aq,
\&        coerce => [
\&            Int    => sub { "$_"                       },
\&            Object => sub { \*(AqAn instance of \*(Aq . ref $_ },
\&        ],
\&    );
.Ve
.SH "NEW KEYWORDS (SUGAR)"
.IX Header "NEW KEYWORDS (SUGAR)"
In addition to all sugar provided by Moose (e.g. has, with, extends), we
provide a couple new keywords.
.SS "\fBclass_type ($class, ?$options)\fP"
.IX Subsection "class_type ($class, ?$options)"
Creates a new subtype of \f(CW\*(C`Object\*(C'\fR with the name \f(CW$class\fR and the
metaclass Moose::Meta::TypeConstraint::Class.
.PP
.Vb 2
\&  # Create a type called \*(AqBox\*(Aq which tests for objects which \->isa(\*(AqBox\*(Aq)
\&  class_type \*(AqBox\*(Aq;
.Ve
.PP
By default, the name of the type and the name of the class are the same, but
you can specify both separately.
.PP
.Vb 2
\&  # Create a type called \*(AqBox\*(Aq which tests for objects which \->isa(\*(AqObjectLibrary::Box\*(Aq);
\&  class_type \*(AqBox\*(Aq, { class => \*(AqObjectLibrary::Box\*(Aq };
.Ve
.PP
(See also Moose::Util::TypeConstraints.)
.SS "\fBrole_type ($role, ?$options)\fP"
.IX Subsection "role_type ($role, ?$options)"
Creates a \f(CW\*(C`Role\*(C'\fR type constraint with the name \f(CW$role\fR and the
metaclass Moose::Meta::TypeConstraint::Role.
.PP
.Vb 2
\&  # Create a type called \*(AqWalks\*(Aq which tests for objects which \->does(\*(AqWalks\*(Aq)
\&  role_type \*(AqWalks\*(Aq;
.Ve
.PP
By default, the name of the type and the name of the role are the same, but
you can specify both separately.
.PP
.Vb 2
\&  # Create a type called \*(AqWalks\*(Aq which tests for objects which \->does(\*(AqMooseX::Role::Walks\*(Aq);
\&  role_type \*(AqWalks\*(Aq, { role => \*(AqMooseX::Role::Walks\*(Aq };
.Ve
.PP
(See also Moose::Util::TypeConstraints.)
.SS "class_has => (...)"
.IX Subsection "class_has => (...)"
Exactly like \*(L"has\*(R" in Moose, but operates at the class (rather than instance)
level.
.PP
(See also MooseX::ClassAttribute.)
.SS "default_for"
.IX Subsection "default_for"
\&\fIdefault_for()\fR is a shortcut to extend an attribute to give it a new default;
this default value may be any legal value for default options.
.PP
.Vb 2
\&    # attribute bar defined elsewhere (e.g. superclass)
\&    default_for bar => \*(Aqnew default\*(Aq;
.Ve
.PP
\&... is the same as:
.PP
.Vb 1
\&    has \*(Aq+bar\*(Aq => (default => \*(Aqnew default\*(Aq);
.Ve
.SS "abstract"
.IX Subsection "abstract"
\&\fIabstract()\fR allows one to declare a method dependency that must be satisfied by a
subclass before it is invoked, and before the subclass is made immutable.
.PP
.Vb 1
\&    abstract \*(Aqmethod_name_that_must_be_satisfied\*(Aq;
.Ve
.SS "requires"
.IX Subsection "requires"
\&\fIrequires()\fR is a synonym for \fIabstract()\fR and works in the way you'd expect.
.SH "OVERLOADS"
.IX Header "OVERLOADS"
It is safe to use overloads in your Reindeer classes and roles; they will
work just as you expect: overloads in classes can be inherited by subclasses;
overloads in roles will be incorporated into consuming classes.
.PP
(See also MooseX::MarkAsMethods)
.SH "AVAILABLE OPTIONAL ATTRIBUTE TRAITS"
.IX Header "AVAILABLE OPTIONAL ATTRIBUTE TRAITS"
We export the following trait aliases.  These traits are not
automatically applied to attributes, and are lazily loaded (e.g. if you don't
use them, they won't be loaded and are not dependencies).
.PP
They can be used by specifying them as:
.PP
.Vb 1
\&    has foo => (traits => [ TraitAlias ], ...);
.Ve
.SS "AutoDestruct"
.IX Subsection "AutoDestruct"
.Vb 7
\&    has foo => (
\&        traits  => [ AutoDestruct ],
\&        is      => \*(Aqro\*(Aq,
\&        lazy    => 1,
\&        builder => 1,
\&        ttl     => 600,
\&    );
.Ve
.PP
Allows for a \*(L"ttl\*(R" attribute option; this is the length of time (in seconds)
that a stored value is allowed to live; after that time the value is cleared
and the value rebuilt (given that the attribute is lazy and has a builder
defined).
.PP
See MooseX::AutoDestruct for more information.
.SS "CascadeClearing"
.IX Subsection "CascadeClearing"
This attribute trait allows one to designate that certain attributes are to be
cleared when certain other ones are; that is, when an attribute is cleared
that clearing will be cascaded down to other attributes.  This is most useful
when you have attributes that are lazily built.
.PP
See MooseX::CascadeClearing for more information and a significantly more
cogent description.
.SS "\s-1ENV\s0"
.IX Subsection "ENV"
This is a Moose attribute trait that you use when you want the default value
for an attribute to be populated from the \f(CW%ENV\fR hash.  So, for example if you
have set the environment variable \s-1USERNAME\s0 to 'John' you can do:
.PP
.Vb 1
\&    package MyApp::MyClass;
\&
\&    use Moose;
\&    use MooseX::Attribute::ENV;
\&
\&    has \*(Aqusername\*(Aq => (is=>\*(Aqro\*(Aq, traits=>[\*(AqENV\*(Aq]);
\&
\&    package main;
\&
\&    my $myclass = MyApp::MyClass\->new();
\&
\&    print $myclass\->username; # STDOUT => \*(AqJohn\*(Aq;
.Ve
.PP
This is basically similar functionality to something like:
.PP
.Vb 6
\&    has \*(Aqattr\*(Aq => (
\&            is=>\*(Aqro\*(Aq,
\&            default=> sub {
\&                    $ENV{uc \*(Aqattr\*(Aq};
\&            },
\&    );
.Ve
.PP
If the named key isn't found in \f(CW%ENV\fR, then defaults will execute as normal.
.PP
See MooseX::Attribute::ENV for more information.
.SS "MultiInitArg"
.IX Subsection "MultiInitArg"
.Vb 6
\&    has \*(Aqdata\*(Aq => (
\&        traits    => [ MultiInitArg ],
\&        is        => \*(Aqro\*(Aq,
\&        isa       => \*(AqStr\*(Aq,
\&        init_args => [qw(munge frobnicate)],
\&    );
.Ve
.PP
This trait allows your attribute to be initialized with any one of multiple
arguments to \fInew()\fR.
.PP
See MooseX::MultiInitArg for more information.
.SS "UndefTolerant"
.IX Subsection "UndefTolerant"
Applying this trait to your attribute makes it's initialization tolerant of
of undef.  If you specify the value of undef to any of the attributes they
will not be initialized (or will be set to the default, if applicable).
Effectively behaving as if you had not provided a value at all.
.PP
.Vb 2
\&    package My:Class;
\&    use Moose;
\&
\&    use MooseX::UndefTolerant::Attribute;
\&
\&    has \*(Aqbar\*(Aq => (
\&        traits    => [ UndefTolerant ],
\&        is        => \*(Aqro\*(Aq,
\&        isa       => \*(AqNum\*(Aq,
\&        predicate => \*(Aqhas_bar\*(Aq
\&    );
\&
\&    # Meanwhile, under the city...
\&
\&    # Doesn\*(Aqt explode
\&    my $class = My::Class\->new(bar => undef);
\&    $class\->has_bar # False!
.Ve
.PP
See MooseX::UndefTolerant::Attribute for more information.
.SH "INCLUDED EXTENSIONS"
.IX Header "INCLUDED EXTENSIONS"
Reindeer includes the traits and sugar provided by the following extensions.
Everything their docs say they can do, you can do by default with Reindeer.
.SS "MooseX::AbstractMethod"
.IX Subsection "MooseX::AbstractMethod"
.SS "MooseX::AlwaysCoerce"
.IX Subsection "MooseX::AlwaysCoerce"
.SS "MooseX::AttributeShortcuts"
.IX Subsection "MooseX::AttributeShortcuts"
.SS "MooseX::ClassAttribute"
.IX Subsection "MooseX::ClassAttribute"
.SS "MooseX::CurriedDelegation"
.IX Subsection "MooseX::CurriedDelegation"
.SS "MooseX::LazyRequire"
.IX Subsection "MooseX::LazyRequire"
.SS "MooseX::MarkAsMethods"
.IX Subsection "MooseX::MarkAsMethods"
Note that this causes any overloads you've defined in your class/role to be
marked as methods, and namespace::autoclean invoked.
.SS "MooseX::NewDefaults"
.IX Subsection "MooseX::NewDefaults"
.SS "MooseX::StrictConstructor"
.IX Subsection "MooseX::StrictConstructor"
.SS "MooseX::Traits"
.IX Subsection "MooseX::Traits"
This provides a new class method, \f(CW\*(C`with_traits()\*(C'\fR, allowing you to compose
traits in on the fly:
.PP
.Vb 1
\&    my $foo = Bar\->with_traits(\*(AqStools\*(Aq)\->new(...);
.Ve
.SH "INCLUDED TYPE LIBRARIES"
.IX Header "INCLUDED TYPE LIBRARIES"
.SS "MooseX::Types::Moose"
.IX Subsection "MooseX::Types::Moose"
.SS "MooseX::Types::Common::String"
.IX Subsection "MooseX::Types::Common::String"
.SS "MooseX::Types::Common::Numeric"
.IX Subsection "MooseX::Types::Common::Numeric"
.SS "MooseX::Types::LoadableClass"
.IX Subsection "MooseX::Types::LoadableClass"
.SS "MooseX::Types::Path::Class"
.IX Subsection "MooseX::Types::Path::Class"
.SS "MooseX::Types::Tied::Hash::IxHash"
.IX Subsection "MooseX::Types::Tied::Hash::IxHash"
.SH "OTHER"
.IX Header "OTHER"
Non-Moose specific items made available to your class/role:
.SS "Perl v5.10 features"
.IX Subsection "Perl v5.10 features"
If you're running on v5.10 or greater of Perl, Reindeer will automatically
enable v5.10 features in the consuming class.
.SS "namespace::autoclean"
.IX Subsection "namespace::autoclean"
Technically, this is done by MooseX::MarkAsMethods, but it's worth pointing
out here.  Any overloads present in your class/role are marked as methods
before autoclean is unleashed, so Everything Will Just Work as Expected.
.SS "Path::Class"
.IX Subsection "Path::Class"
.Vb 1
\&  use Path::Class;
\&  
\&  my $dir  = dir(\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq);       # Path::Class::Dir object
\&  my $file = file(\*(Aqbob\*(Aq, \*(Aqfile.txt\*(Aq); # Path::Class::File object
\&  
\&  # Stringifies to \*(Aqfoo/bar\*(Aq on Unix, \*(Aqfoo\ebar\*(Aq on Windows, etc.
\&  print "dir: $dir\en";
\&  
\&  # Stringifies to \*(Aqbob/file.txt\*(Aq on Unix, \*(Aqbob\efile.txt\*(Aq on Windows
\&  print "file: $file\en";
\&  
\&  my $subdir  = $dir\->subdir(\*(Aqbaz\*(Aq);  # foo/bar/baz
\&  my $parent  = $subdir\->parent;      # foo/bar
\&  my $parent2 = $parent\->parent;      # foo
\&  
\&  my $dir2 = $file\->dir;              # bob
\&
\&  # Work with foreign paths
\&  use Path::Class qw(foreign_file foreign_dir);
\&  my $file = foreign_file(\*(AqMac\*(Aq, \*(Aq:foo:file.txt\*(Aq);
\&  print $file\->dir;                   # :foo:
\&  print $file\->as_foreign(\*(AqWin32\*(Aq);   # foo\efile.txt
\&  
\&  # Interact with the underlying filesystem:
\&  
\&  # $dir_handle is an IO::Dir object
\&  my $dir_handle = $dir\->open or die "Can\*(Aqt read $dir: $!";
\&  
\&  # $file_handle is an IO::File object
\&  my $file_handle = $file\->open($mode) or die "Can\*(Aqt read $file: $!";
.Ve
.PP
See the Path::Class documentation for more detail.
.SS "Try::Tiny"
.IX Subsection "Try::Tiny"
You can use Try::Tiny's \f(CW\*(C`try\*(C'\fR and \f(CW\*(C`catch\*(C'\fR to expect and handle exceptional
conditions, avoiding quirks in Perl and common mistakes:
.PP
.Vb 6
\&  # handle errors with a catch handler
\&  try {
\&    die "foo";
\&  } catch {
\&    warn "caught error: $_"; # not $@
\&  };
.Ve
.PP
You can also use it like a standalone \f(CW\*(C`eval\*(C'\fR to catch and ignore any error
conditions.  Obviously, this is an extreme measure not to be undertaken
lightly:
.PP
.Vb 4
\&  # just silence errors
\&  try {
\&    die "foo";
\&  };
.Ve
.PP
See the Try::Tiny documentation for more detail.
.SH "CAVEAT"
.IX Header "CAVEAT"
This author is applying his own assessment of \*(L"useful/popular extensions\*(R".
You may find yourself in agreement, or violent disagreement with his choices.
\&\s-1YMMV :\s0)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
Reindeer serves largely to tie together other packages \*(-- Moose extensions and
other common modules.  Those other packages are largely by other people,
without whose work Reindeer would have a significantly smaller rack.
.PP
We also use documentation as written for the other packages pulled in here to
help present a cohesive whole.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Please see those modules/websites for more information related to this module.
.IP "\(bu" 4
Moose, and all of the above-referenced packages.
.SH "SOURCE"
.IX Header "SOURCE"
The development version is on github at <http://github.com/RsrchBoy/reindeer>
and may be cloned from <git://github.com/RsrchBoy/reindeer.git>
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests on the bugtracker website
https://github.com/RsrchBoy/reindeer/issues
.PP
When submitting a bug or request, please include a test-file or a
patch to an existing test-file that illustrates the bug or desired
feature.
.SH "AUTHOR"
.IX Header "AUTHOR"
Chris Weyl <cweyl@alumni.drew.edu>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2011 by Chris Weyl.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The GNU Lesser General Public License, Version 2.1, February 1999
.Ve
