.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Git::Repository 3"
.TH Git::Repository 3 "2014-03-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Git::Repository \- Perl interface to Git repositories
.SH "VERSION"
.IX Header "VERSION"
version 1.311
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Git::Repository;
\&
\&    # start from an existing repository
\&    $r = Git::Repository\->new( git_dir => $gitdir );
\&
\&    # start from an existing working copy
\&    $r = Git::Repository\->new( work_tree => $dir );
\&
\&    # start from a repository reachable from the current directory
\&    $r = Git::Repository\->new();
\&
\&    # or init our own repository first
\&    Git::Repository\->run( init => $dir, ... );
\&    $r = Git::Repository\->new( work_tree => $dir );
\&
\&    # or clone from a URL first
\&    Git::Repository\->run( clone => $url, $dir, ... );
\&    $r = Git::Repository\->new( work_tree => $dir );
\&
\&    # provide an option hash for Git::Repository::Command
\&    # (see Git::Repository::Command for all available options)
\&    $r = Git::Repository\->new( ..., \e%options );
\&
\&    # run commands
\&    # \- get the full output (no errput) passing options for this command only
\&    $output = $r\->run( @cmd, \e%options );
\&
\&    # \- get the full output as a list of lines (no errput), with options
\&    @output = $r\->run( @cmd, \e%options );
\&
\&    # \- process the output with callbacks
\&    $output = $r\->run( @cmd, sub {...} );
\&    @output = $r\->run( @cmd, sub {...} );
\&
\&    # \- obtain a Git::Repository::Command object
\&    #   (see Git::Repository::Command for details)
\&    $cmd = $r\->command( @cmd, \e%options );
\&
\&    # obtain version information
\&    my $version = $r\->version();
\&
\&    # compare current git version
\&    if ( $r\->version_gt(\*(Aq1.6.5\*(Aq) ) {
\&        ...;
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Git::Repository is a Perl interface to Git, for scripted interactions
with repositories. It's a low-level interface that allows calling any Git
command, whether \fIporcelain\fR or \fIplumbing\fR, including bidirectional
commands such as \f(CW\*(C`git commit\-tree\*(C'\fR.
.PP
A Git::Repository object simply provides context to the git commands
being run. It is possible to call the  \f(CW\*(C`command()\*(C'\fR and \f(CW\*(C`run()\*(C'\fR methods
against the class itself, and the context (typically \fIcurrent working
directory\fR) will be obtained from the options and environment.
.PP
As a low-level interface, it provides no sugar for particular Git
commands. Specifically, it will not prepare environment variables that
individual Git commands may need or use.
.PP
However, the \f(CW\*(C`GIT_DIR\*(C'\fR and \f(CW\*(C`GIT_WORK_TREE\*(C'\fR environment variables are
special: if the command is run in the context of a Git::Repository
object, they will be overridden by the object's \f(CW\*(C`git_dir\*(C'\fR and
\&\f(CW\*(C`work_tree\*(C'\fR attributes, respectively. It is however still possible to
override them if necessary, using the \f(CW\*(C`env\*(C'\fR option.
.PP
Git::Repository requires at least Git 1.5.0, and is expected to support
any later version.
.PP
See Git::Repository::Tutorial for more code examples.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "new"
.IX Subsection "new"
.Vb 1
\&    Git::Repository\->new( %args, $options );
.Ve
.PP
Create a new Git::Repository object, based on an existing Git repository.
.PP
Parameters are:
.ie n .IP "git_dir => $gitdir" 4
.el .IP "git_dir => \f(CW$gitdir\fR" 4
.IX Item "git_dir => $gitdir"
The location of the git repository (\fI.git\fR directory or equivalent).
.Sp
For backward compatibility with versions 1.06 and before, \f(CW\*(C`repository\*(C'\fR
is accepted in place of \f(CW\*(C`git_dir\*(C'\fR (but the newer name takes precedence).
.ie n .IP "work_tree => $dir" 4
.el .IP "work_tree => \f(CW$dir\fR" 4
.IX Item "work_tree => $dir"
The location of the git working copy (for a non-bare repository).
.Sp
If \f(CW\*(C`work_tree\*(C'\fR actually points to a subdirectory of the work tree,
Git::Repository will automatically recompute the proper value.
.Sp
For backward compatibility with versions 1.06 and before, \f(CW\*(C`working_copy\*(C'\fR
is accepted in place of \f(CW\*(C`work_tree\*(C'\fR (but the newer name takes precedence).
.PP
If none of the parameter is given, Git::Repository will find the
appropriate repository just like Git itself does. Otherwise, one of
the parameters is usually enough,
as Git::Repository can work out where the other directory (if any) is.
.PP
\&\f(CW\*(C`new()\*(C'\fR also accepts a reference to an option hash which will be used
as the default by Git::Repository::Command when working with the
corresponding Git::Repository instance.
.PP
So this:
.PP
.Vb 11
\&    my $r = Git::Repository\->new(
\&        # parameters
\&        work_tree => $dir,
\&        # options
\&        {   git => \*(Aq/path/to/some/other/git\*(Aq,
\&            env => {
\&                GIT_COMMITTER_EMAIL => \*(Aqbook@cpan.org\*(Aq,
\&                GIT_COMMITTER_NAME  => \*(AqPhilippe Bruhat (BooK)\*(Aq,
\&            },
\&        }
\&    );
.Ve
.PP
is equivalent to explicitly passing the option hash to each
\&\f(CW\*(C`run()\*(C'\fR or \f(CW\*(C`command()\*(C'\fR call.
The documentation for Git::Repository::Command lists all
available options.
.PP
Note that Git::Repository and Git::Repository::Command take
great care in finding the option hash wherever it may be in \f(CW@_\fR,
and to merge multiple option hashes if more than one is provided.
.PP
It probably makes no sense to set the \f(CW\*(C`input\*(C'\fR option in \f(CW\*(C`new()\*(C'\fR,
but Git::Repository won't stop you.
Note that on some systems, some git commands may close standard input
on startup, which will cause a \f(CW\*(C`SIGPIPE\*(C'\fR. Git::Repository::Command
will raise an exception.
.PP
To create a Git repository and obtain a Git::Repository object
pointing to it, simply do it in two steps:
.PP
.Vb 3
\&    # run a clone or init command without an instance,
\&    # using options like cwd
\&    Git::Repository\->run( ... );
\&    
\&    # obtain a Git::Repository instance
\&    # on the resulting repository
\&    $r = Git::Repository\->new( ... );
.Ve
.SH "METHODS"
.IX Header "METHODS"
Git::Repository supports the following methods:
.SS "command"
.IX Subsection "command"
.Vb 2
\&    Git::Repository\->command( @cmd );
\&    $r\->command( @cmd );
.Ve
.PP
Runs the git sub-command and options, and returns a Git::Repository::Command
object pointing to the sub-process running the command.
.PP
As described in the Git::Repository::Command documentation, \f(CW@cmd\fR
may also contain a hashref containing options for the command.
.SS "run"
.IX Subsection "run"
.Vb 2
\&    Git::Repository\->run( @cmd );
\&    $r\->run( @cmd );
.Ve
.PP
Runs the command and returns the output as a string in scalar context,
or as a list of lines in list context. Also accepts a hashref of options.
.PP
Lines are automatically \f(CW\*(C`chomp\*(C'\fRed.
.PP
In addition to the options hashref supported by Git::Repository::Command,
the parameter list can also contain code references, that will be applied
successively to each line of output. The line being processed is in \f(CW$_\fR,
but the coderef must still return the result string (like \f(CW\*(C`map\*(C'\fR).
.PP
If the git command printed anything on stderr, it will be printed as
warnings. For convenience, if the git sub-process exited with status
\&\f(CW128\fR (fatal error), or \f(CW129\fR (usage message), \f(CW\*(C`run()\*(C'\fR will \f(CW\*(C`die()\*(C'\fR.
The exit status values for which \f(CW\*(C`run()\*(C'\fR dies can be modified using
the \f(CW\*(C`fatal\*(C'\fR option (see Git::Repository::Command for details).
.PP
The exit status of the command that was just run is accessible as usual
using \f(CW\*(C`$? >> 8\*(C'\fR. See perlvar for details about \f(CW$?\fR.
.SS "git_dir"
.IX Subsection "git_dir"
Returns the repository path.
.SS "work_tree"
.IX Subsection "work_tree"
Returns the working copy path.
Used as current working directory by Git::Repository::Command.
.SS "options"
.IX Subsection "options"
Return the option hash that was passed to \f(CW\*(C`Git::Repository\->new()\*(C'\fR.
.SS "version"
.IX Subsection "version"
Return the version of git, as given by \f(CW\*(C`git \-\-version\*(C'\fR.
.ie n .SS "Version-comparison ""operators"""
.el .SS "Version-comparison ``operators''"
.IX Subsection "Version-comparison operators"
Git evolves very fast, and new features are constantly added.
To facilitate the creation of programs that can properly handle the
wide variety of Git versions seen in the wild, a number of version
comparison \*(L"operators\*(R" are available.
.PP
They are named \f(CW\*(C`version_\f(CIop\f(CW\*(C'\fR where \fIop\fR is the equivalent of the Perl
operators \f(CW\*(C`lt\*(C'\fR, \f(CW\*(C`gt\*(C'\fR, \f(CW\*(C`le\*(C'\fR, \f(CW\*(C`ge\*(C'\fR, \f(CW\*(C`eq\*(C'\fR, \f(CW\*(C`ne\*(C'\fR. They return a boolean
value, obtained by comparing the version of the git binary and the
version string passed as parameter.
.PP
The methods are:
.ie n .IP "version_lt( $version )" 4
.el .IP "version_lt( \f(CW$version\fR )" 4
.IX Item "version_lt( $version )"
.PD 0
.ie n .IP "version_gt( $version )" 4
.el .IP "version_gt( \f(CW$version\fR )" 4
.IX Item "version_gt( $version )"
.ie n .IP "version_le( $version )" 4
.el .IP "version_le( \f(CW$version\fR )" 4
.IX Item "version_le( $version )"
.ie n .IP "version_ge( $version )" 4
.el .IP "version_ge( \f(CW$version\fR )" 4
.IX Item "version_ge( $version )"
.ie n .IP "version_eq( $version )" 4
.el .IP "version_eq( \f(CW$version\fR )" 4
.IX Item "version_eq( $version )"
.ie n .IP "version_ne( $version )" 4
.el .IP "version_ne( \f(CW$version\fR )" 4
.IX Item "version_ne( $version )"
.PD
.PP
All those methods also accept an option hash, just like the others.
.PP
Note that there are a small number of cases where the version comparison
operators will \fInot\fR compare versions correctly for \fIvery old\fR versions of
Git. Typical example is \f(CW\*(C`1.0.0a gt 1.0.0\*(C'\fR which should return true, but
doesn't. This only matters in comparisons, only for version numbers prior to
\&\f(CW\*(C`1.4.0\-rc1\*(C'\fR (June 2006), and only when the compared versions are very close.
.PP
Other issues exist when comparing development version numbers with one
another. For example, \f(CW1.7.1.1\fR is greater than both \f(CW\*(C`1.7.1.1.gc8c07\*(C'\fR
and \f(CW\*(C`1.7.1.1.g5f35a\*(C'\fR, and \f(CW1.7.1\fR is less than both. Obviously,
\&\f(CW\*(C`1.7.1.1.gc8c07\*(C'\fR will compare as greater than \f(CW\*(C`1.7.1.1.g5f35a\*(C'\fR
(asciibetically), but in fact these two version numbers cannot be
compared, as they are two siblings children of the commit tagged
\&\f(CW\*(C`v1.7.1\*(C'\fR).
.PP
If one were to compute the set of all possible version numbers (as returned
by \f(CW\*(C`git \-\-version\*(C'\fR) for all git versions that can be compiled from each
commit in the \fIgit.git\fR repository, the result would not be a totally ordered
set. Big deal.
.PP
Also, don't be too precise when requiring the minimum version of Git that
supported a given feature. The precise commit in git.git at which a given
feature was added doesn't mean as much as the release branch in which that
commit was merged.
.SH "PLUGIN SUPPORT"
.IX Header "PLUGIN SUPPORT"
Git::Repository intentionally has only few methods.
The idea is to provide a lightweight wrapper around git, to be used
to create interesting tools based on Git.
.PP
However, people will want to add extra functionality to Git::Repository,
the obvious example being a \f(CW\*(C`log()\*(C'\fR method that returns simple objects
with useful attributes.
.PP
Taking the hypothetical \f(CW\*(C`Git::Repository::Plugin::Hello\*(C'\fR module which
source code is listed in the previous reference, the methods it provides
would be loaded and used as follows:
.PP
.Vb 1
\&    use Git::Repository qw( Hello );
\&
\&    my $r = Git::Repository\->new();
\&    print $r\->hello();
\&    print $r\->hello_gitdir();
.Ve
.PP
It's possible to load only a selection of methods from the plugin:
.PP
.Vb 1
\&    use Git::Repository [ Hello => \*(Aqhello\*(Aq ];
\&
\&    my $r = Git::Repository\->new();
\&    print $r\->hello();
\&
\&    # dies: Can\*(Aqt locate object method "hello_gitdir"
\&    print $r\->hello_gitdir();
.Ve
.PP
If your plugin lives in another namespace than \f(CW\*(C`Git::Repository::Plugin::\*(C'\fR,
just prefix the fully qualified class name with a \f(CW\*(C`+\*(C'\fR. For example:
.PP
.Vb 1
\&    use Git::Repository qw( +MyGit::Hello );
.Ve
.PP
See Git::Repository::Plugin about how to create a new plugin.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to Todd Rinaldo, who wanted to add more methods to
Git::Repository, which made me look for a solution that would preserve
the minimalism of Git::Repository. The \f(CW\*(C`::Plugin\*(C'\fR interface is what
I came up with.
.SH "OTHER PERL GIT WRAPPERS"
.IX Header "OTHER PERL GIT WRAPPERS"
(This section was written in June 2010. The other Git wrappers have
probably evolved since that time.)
.PP
A number of Perl git wrappers already exist. Why create a new one?
.PP
I have a lot of ideas of nice things to do with Git as a tool to
manipulate blobs, trees, and tags, that may or may not represent
revision history of a project. A lot of those commands can output
huge amounts of data, which I need to be able to process in chunks.
Some of these commands also expect to receive input.
.PP
What follows is a short list of \*(L"missing features\*(R" that I was looking
for when I looked at the existing Git wrappers on \s-1CPAN.\s0 They are the
\&\*(L"rational\*(R" reason for writing my own (the real reason being of course
\&\*(L"I thought it would be fun, and I enjoyed doing it\*(R").
.PP
Even though it works well for me and others, Git::Repository has its
own shortcomings: it \fIis\fR a \fIlow-level interface to Git commands\fR,
anything complex requires you to deal with input/output handles,
it provides no high-level interface to generate actual Git commands
or process the output of commands (but have a look at the plugins), etc.
One the following modules may therefore be better suited for your needs,
depending on what you're trying to achieve.
.SS "Git.pm"
.IX Subsection "Git.pm"
Git.pm is not on \s-1CPAN.\s0 It is usually packaged with Git, and installed with
the system Perl libraries. Not being on \s-1CPAN\s0 makes it harder to install
in any Perl. It makes it harder for a \s-1CPAN\s0 library to depend on it.
.PP
It doesn't allow calling \f(CW\*(C`git init\*(C'\fR or \f(CW\*(C`git clone\*(C'\fR.
.PP
The \f(CW\*(C`command_bidi_pipe\*(C'\fR function especially has problems:
<http://kerneltrap.org/mailarchive/git/2008/10/24/3789584>
.SS "Git::Class"
.IX Subsection "Git::Class"
Git::Class
depends on Moose, which seems an unnecessary dependency for a simple
wrapper around Git. The startup penalty could become significant for
command-line tools.
.PP
Although it supports \f(CW\*(C`git init\*(C'\fR and \f(CW\*(C`git clone\*(C'\fR
(and has methods to call any Git command), it is mostly aimed at
porcelain commands, and provides no way to control bidirectional commands
(such as \f(CW\*(C`git commit\-tree\*(C'\fR).
.SS "Git::Wrapper"
.IX Subsection "Git::Wrapper"
Git::Wrapper
doesn't support streams or bidirectional commands.
.SS "Git::Sub"
.IX Subsection "Git::Sub"
(This description was added for completeness in May 2013.)
.PP
Git::Sub appeared in 2013, as a set of Git-specific System::Sub
functions. It provide a nice set of \f(CW\*(C`git::\*(C'\fR functions, and has some
limitations (due to the way System::Sub itself works) which don't
impact most Git commands.
.PP
Git::Sub doesn't support working with streams.
.SH "BUGS"
.IX Header "BUGS"
Since version 1.17, Git::Repository delegates the actual command
execution to System::Command, which has better support for Win32
since version 1.100.
.PP
Please report any bugs or feature requests to \f(CW\*(C`bug\-git\-repository at rt.cpan.org\*(C'\fR, or through
the web interface at <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Git\-Repository>.  I will be notified, and then you'll
automatically be notified of progress on your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Git::Repository
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Git\-Repository>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/Git\-Repository>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/Git\-Repository>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/Git\-Repository>
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests on the bugtracker website
http://rt.cpan.org/NoAuth/Bugs.html?Dist=Git\-Repository or by email to
bug\-git\-repository@rt.cpan.org.
.PP
When submitting a bug or request, please include a test-file or a
patch to an existing test-file that illustrates the bug or desired
feature.
.SH "AUTHOR"
.IX Header "AUTHOR"
Philippe Bruhat (BooK) <book@cpan.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2010\-2014 Philippe Bruhat (BooK), all rights reserved.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
