.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "autobox::Core 3"
.TH autobox::Core 3 "2013-07-18" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
autobox::Core \- Provide core functions to autoboxed scalars, arrays and hashes.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use autobox::Core;
\&
\&  "Hello, World\en"\->uc\->print;
\&
\&  my @list = (1, 5, 9, 2, 0, 4, 2, 1);
\&  @list\->sort\->reverse\->print;
\&
\&  # works with references too!
\&  my $list = [1, 5, 9, 2, 0, 4, 2, 1];
\&  $list\->sort\->reverse\->print;
\&
\&  my %hash = (
\&      grass => \*(Aqgreen\*(Aq,
\&      apple => \*(Aqred\*(Aq,
\&      sky   => \*(Aqblue\*(Aq,
\&  );
\&
\&  [10, 20, 30, 40, 50]\->pop\->say;
\&  [10, 20, 30, 40, 50]\->shift\->say;
\&
\&  my $lala = "Lalalalala\en"; 
\&  "chomp: "\->concat($lala\->chomp, " ", $lala)\->say;
\&
\&  my $hashref = { foo => 10, bar => 20, baz => 30, qux => 40 };
\&
\&  print "hash keys: ", $hashref\->keys\->join(\*(Aq \*(Aq), "\en"; # or if you prefer...
\&  print "hash keys: ", join \*(Aq \*(Aq, $hashref\->keys(), "\en"; # or
\&  print "hash keys: "; $hashref\->keys\->say;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The autobox module promotes Perl's primitive types (literals (strings and
numbers), scalars, arrays and hashes) into first-class objects.  However,
autobox does not provide any methods for these new classes.
.PP
autobox::CORE provides a set of methods for these new classes.  It includes
almost everything in perlfunc, some things from Scalar::Util and
List::Util, and some Perl 5 versions of methods taken from Perl 6.
.PP
With \fIautobox::Core\fR one is able to change this:
.PP
.Vb 1
\&        print join(" ", reverse(split(" ", $string)));
.Ve
.PP
to this:
.PP
.Vb 1
\&        use autobox::Core;
\&
\&        $string\->split(" ")\->reverse\->print;
.Ve
.PP
Likewise you can change this:
.PP
.Vb 1
\&        my $array_ref = [qw(fish dog cat elephant bird)];
\&
\&        push @$array_ref, qw(snake lizard giraffe mouse);
.Ve
.PP
to this:
.PP
.Vb 2
\&        use autobox::Core;
\&        my $array_ref = [qw(fish dog cat elephant bird)];
\&
\&        $array_ref\->push( qw(snake lizard giraffe mouse));
.Ve
.PP
\&\fIautobox::Core\fR makes it easier to avoid parentheses pile ups and
messy dereferencing syntaxes.
.PP
\&\fIautobox::Core\fR is mostly glue.  It presents existing functions with a new
interface, while adding few extra. Most of the methods read like 
\&\f(CW\*(C`sub hex { CORE::hex($_[0]) }\*(C'\fR.  In addition to built-ins from
perlfunc that operate on hashes, arrays, scalars, and code references,
some Perl 6\-ish things have been included, and some keywords like
\&\f(CW\*(C`foreach\*(C'\fR are represented too.
.SS "What's Implemented?"
.IX Subsection "What's Implemented?"
.IP "\(bu" 4
Many of the functions listed in perlfunc under the headings:
.RS 4
.IP "\(bu" 4
\&\*(L"Functions for real \f(CW@ARRAYs\fR\*(R",
.IP "\(bu" 4
\&\*(L"Functions for real \f(CW%HASHes\fR\*(R",
.IP "\(bu" 4
\&\*(L"Functions for list data\*(R",
.IP "\(bu" 4
\&\*(L"Functions for SCALARs or strings\*(R"
.RE
.RS 4
.Sp
plus a few taken from other sections and documented below.
.RE
.IP "\(bu" 4
Some methods from Scalar::Util and List::Util.
.IP "\(bu" 4
Some things expected in Perl 6, such as \f(CW\*(C`last\*(C'\fR (\f(CW\*(C`last_idx\*(C'\fR), \f(CW\*(C`elems\*(C'\fR, and
\&\f(CW\*(C`curry\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`flatten\*(C'\fR explicitly flattens an array.
.PP
\fIString Methods\fR
.IX Subsection "String Methods"
.PP
String methods are of the form \f(CW\*(C`my $return = $string\->method(@args)\*(C'\fR.
Some will act on the \f(CW$string\fR and some will return a new string.
.PP
Many string methods are simply wrappers around core functions, but
there are additional operations and modifications to core behavior.
.PP
Anything which takes a regular expression, such as split and m,
usually take it in the form of a compiled regex (\f(CW\*(C`qr//\*(C'\fR).  Any modifiers
can be attached to the \f(CW\*(C`qr\*(C'\fR normally.
.PP
These built in functions are implemented for scalars, they work just like normal:
chomp, chop,chr
crypt, index, lc
lcfirst, length, ord,
pack, reverse (always in scalar
context), rindex,
sprintf, substr, uc
ucfirst, unpack, quotemeta,
vec, undef, 
split, system, eval.
.PP
In addition, so are each of the following:
.PP
concat
.IX Subsection "concat"
.PP
.Vb 1
\&   $string1\->concat($string2);
.Ve
.PP
Concatenates \f(CW$string2\fR to \f(CW$string1\fR. This 
corresponds to the \f(CW\*(C`.\*(C'\fR operator used to join two strings.  Returns the
joined strings.
.PP
strip
.IX Subsection "strip"
.PP
Removes whitespace from the beginning and end of a string.
.PP
.Vb 1
\&   " \et  \en  \et  foo  \et  \en  \et  "\->strip;    # foo
.Ve
.PP
This is redundant and subtly different from \f(CW\*(C`trim\*(C'\fR which allows for the
removal of specific characters from the beginning and end of a string.
.PP
trim
.IX Subsection "trim"
.PP
Removes whitespace from the beginning and end of a string.  \f(CW\*(C`trim\*(C'\fR
can also remove specific characters from the beginning and the end of
string.
.PP
.Vb 3
\&   \*(Aq    hello\*(Aq\->trim;                   # \*(Aqhello\*(Aq
\&   \*(Aq*+* hello *+*\*(Aq\->trim("*+");         # \*(Aq hello \*(Aq 
\&   \*(Aq *+* hello *+*\*(Aq\->trim("*+");        # \*(Aq *+* hello\*(Aq
.Ve
.PP
ltrim
.IX Subsection "ltrim"
.PP
Just like trim but it only trims the left side (start) of the string.
.PP
.Vb 2
\&   \*(Aq    hello\*(Aq\->ltrim;                  # \*(Aqhello\*(Aq
\&   \*(Aq*+* hello *+*\*(Aq\->trim("*+");         # \*(Aq hello *+*\*(Aq
.Ve
.PP
rtrim
.IX Subsection "rtrim"
.PP
Just like trim but it only trims the right side (end) of the string.
.PP
.Vb 2
\&   \*(Aqhello   \*(Aq\->rtrim;                   # \*(Aqhello\*(Aq
\&   \*(Aq*+* hello *+*\*(Aq\->rtrim("*+");        # \*(Aq*+* hello \*(Aq
.Ve
.PP
split
.IX Subsection "split"
.PP
.Vb 1
\&    my @split_string = $string\->split(qr/.../);
.Ve
.PP
A wrapper around split.  It takes the regular
expression as a compiled regex.
.PP
.Vb 2
\&   print "10, 20, 30, 40"\->split(qr{, ?})\->elements, "\en";
\&   "hi there"\->split(qr/ */);           # h i t h e r e
.Ve
.PP
The limit argument is not implemented.
.PP
title_case
.IX Subsection "title_case"
.PP
\&\f(CW\*(C`title_case\*(C'\fR converts the first character of each word in the string to
upper case.
.PP
.Vb 1
\&   "this is a test"\->title_case;        # This Is A Test
.Ve
.PP
center
.IX Subsection "center"
.PP
.Vb 2
\&    my $centered_string = $string\->center($length);
\&    my $centered_string = $string\->center($length, $character);
.Ve
.PP
Centers \f(CW$string\fR between \f(CW$character\fR.  \f(CW$centered_string\fR will be of
length \f(CW$length\fR, or the length of \f(CW$string\fR, whichever is greater.
.PP
\&\f(CW$character\fR defaults to \*(L" \*(R".
.PP
.Vb 2
\&    say "Hello"\->center(10);        # "   Hello  ";
\&    say "Hello"\->center(10, \*(Aq\-\*(Aq);   # "\-\-\-Hello\-\-";
.Ve
.PP
\&\f(CW\*(C`center()\*(C'\fR will never truncate \f(CW$string\fR.  If \f(CW$length\fR is less
than \f(CW\*(C`$string\->length\*(C'\fR it will just return \f(CW$string\fR.
.PP
.Vb 1
\&    say "Hello"\->center(4);        # "Hello";
.Ve
.PP
backtick
.IX Subsection "backtick"
.PP
.Vb 1
\&    my $output = $string\->backtick;
.Ve
.PP
Runs \f(CW$string\fR as a command just like \f(CW\*(C`\`$string\`\*(C'\fR.
.PP
nm
.IX Subsection "nm"
.PP
.Vb 3
\&    if( $foo\->nm(qr/bar/) ) {
\&        say "$foo did not match \*(Aqbar\*(Aq";
\&    }
.Ve
.PP
\&\*(L"Negative match\*(R".  Corresponds to \f(CW\*(C`!~\*(C'\fR.  Otherwise works in the same
way as \f(CW\*(C`m()\*(C'\fR.
.PP
m
.IX Subsection "m"
.PP
.Vb 3
\&    if( $foo\->m(qr/bar/) ) {
\&        say "$foo matched \*(Aqbar\*(Aq";
\&    }
\&
\&    my $matches = $foo\->m( qr/(\ed*) (\ew+)/ );
\&    say $matches\->[0];
\&    say $matches\->[1];
.Ve
.PP
Works the same as \f(CW\*(C`m//\*(C'\fR, but the regex must be passed in as a \f(CW\*(C`qr//\*(C'\fR.
.PP
\&\f(CW\*(C`m\*(C'\fR returns an array reference so that list functions such as \f(CW\*(C`map\*(C'\fR and
\&\f(CW\*(C`grep\*(C'\fR may be called on the result.  Use \f(CW\*(C`elements\*(C'\fR to turn this into a
list of values.
.PP
.Vb 2
\&  my ($street_number, $street_name, $apartment_number) =
\&      "1234 Robin Drive #101"\->m( qr{(\ed+) (.*)(?: #(\ed+))?} )\->elements;
\&
\&  print "$street_number $street_name $apartment_number\en";
.Ve
.PP
s
.IX Subsection "s"
.PP
.Vb 3
\&  my $string = "the cat sat on the mat";
\&  $string\->s( qr/cat/, "dog" );
\&  $string\->say;                 # the dog sat on the mat
.Ve
.PP
Works the same as \f(CW\*(C`s///\*(C'\fR.  Returns the number of substitutions
performed, not the target string.
.PP
undef
.IX Subsection "undef"
.PP
.Vb 1
\&    $string\->undef;
.Ve
.PP
Assigns \f(CW\*(C`undef\*(C'\fR to the \f(CW$string\fR.
.PP
defined
.IX Subsection "defined"
.PP
.Vb 1
\&    my $is_defined = $string\->defined;
\&
\&    if( not $string\->defined ) {
\&        # give $string a value...
\&    }
.Ve
.PP
\&\f(CW\*(C`defined\*(C'\fR tests whether a value is defined (not \f(CW\*(C`undef\*(C'\fR).
.PP
repeat
.IX Subsection "repeat"
.PP
.Vb 1
\&    my $repeated_string = $string\->repeat($n);
.Ve
.PP
Like the \f(CW\*(C`x\*(C'\fR operator, repeats a string \f(CW$n\fR times.
.PP
.Vb 2
\&    print 1\->repeat(5);     # 11111
\&    print "\en"\->repeat(10); # ten newlines
.Ve
.PP
\fII/O Methods\fR
.IX Subsection "I/O Methods"
.PP
These are methods having to do with input and ouptut, not filehandles.
.PP
print
.IX Subsection "print"
.PP
.Vb 1
\&    $string\->print;
.Ve
.PP
Prints a string or a list of strings.  Returns true if successful.
.PP
say
.IX Subsection "say"
.PP
Like print, but implicitly appends a newline to the end.
.PP
.Vb 1
\&     $string\->say;
.Ve
.PP
\fIBoolean Methods\fR
.IX Subsection "Boolean Methods"
.PP
Methods related to boolean operations.
.PP
and
.IX Subsection "and"
.PP
\&\f(CW\*(C`and\*(C'\fR corresponds to \f(CW\*(C`&&\*(C'\fR.  Returns true if both operands are true.
.PP
.Vb 3
\&        if( $a\->and($b) ) {
\&            ...
\&        }
.Ve
.PP
not
.IX Subsection "not"
.PP
\&\f(CW\*(C`not\*(C'\fR corresponds to \f(CW\*(C`!\*(C'\fR.  Returns true if the subject is false.
.PP
.Vb 3
\&        if( $a\->not ) {
\&            ...
\&        }
.Ve
.PP
or
.IX Subsection "or"
.PP
\&\f(CW\*(C`or\*(C'\fR corresponds to \f(CW\*(C`||\*(C'\fR.  Returns true if at least one of the operands
is true.
.PP
.Vb 3
\&        if( $a\->or($b) ) {
\&            ...
\&        }
.Ve
.PP
xor
.IX Subsection "xor"
.PP
\&\f(CW\*(C`xor\*(C'\fR corresponds to \f(CW\*(C`xor\*(C'\fR.  Returns true if only one of the operands is
true.
.PP
.Vb 3
\&        if( $a\->xor($b) ) {
\&            ...
\&        }
.Ve
.PP
\fINumber Related Methods\fR
.IX Subsection "Number Related Methods"
.PP
Methods related to numbers.
.PP
The basic built in functions which operate as normal :
abs, atan2, cos,
exp, int, log,
oct, hex, sin, and
sqrt.
.PP
The following operators were also included:
.PP
dec
.IX Subsection "dec"
.PP
.Vb 2
\&    $number\->dec();
\&    # $number is smaller by 1.
.Ve
.PP
\&\f(CW\*(C`dec\*(C'\fR corresponds to \f(CW\*(C`++\*(C'\fR.  Decrements subject, will decrement character
strings too: 'b' decrements to 'a'.
.PP
inc
.IX Subsection "inc"
.PP
\&\f(CW\*(C`inc\*(C'\fR corresponds to \f(CW\*(C`++\*(C'\fR.  Increments subject, will increment character
strings too. 'a' increments to 'b'.
.PP
mod
.IX Subsection "mod"
.PP
\&\f(CW\*(C`mod\*(C'\fR corresponds to \f(CW\*(C`%\*(C'\fR.
.PP
.Vb 1
\&        $number\->mod(5);
.Ve
.PP
pow
.IX Subsection "pow"
.PP
\&\f(CW\*(C`pow\*(C'\fR returns \f(CW$number\fR raised to the power of the \f(CW$exponent\fR.
.PP
.Vb 2
\&    my $result = $number\->pow($expontent);
\&    print 2\->pow(8);  # 256
.Ve
.PP
is_number
.IX Subsection "is_number"
.PP
.Vb 1
\&    $is_a_number = $thing\->is_number;
.Ve
.PP
Returns true if \f(CW$thing\fR is a number as understood by Perl.
.PP
.Vb 2
\&    12.34\->is_number;           # true
\&    "12.34"\->is_number;         # also true
.Ve
.PP
is_positive
.IX Subsection "is_positive"
.PP
.Vb 1
\&    $is_positive = $thing\->is_positive;
.Ve
.PP
Returns true if \f(CW$thing\fR is a positive number.
.PP
\&\f(CW0\fR is not positive.
.PP
is_negative
.IX Subsection "is_negative"
.PP
.Vb 1
\&    $is_negative = $thing\->is_negative;
.Ve
.PP
Returns true if \f(CW$thing\fR is a negative number.
.PP
\&\f(CW0\fR is not negative.
.PP
is_integer
.IX Subsection "is_integer"
.PP
.Vb 1
\&    $is_an_integer = $thing\->is_integer;
.Ve
.PP
Returns true if \f(CW$thing\fR is an integer.
.PP
.Vb 2
\&    12\->is_integer;             # true
\&    12.34\->is_integer;          # false
.Ve
.PP
is_int
.IX Subsection "is_int"
.PP
A synonym for is_integer.
.PP
is_decimal
.IX Subsection "is_decimal"
.PP
.Vb 1
\&    $is_a_decimal_number = $thing\->is_decimal;
.Ve
.PP
Returns true if \f(CW$thing\fR is a decimal number.
.PP
.Vb 3
\&    12\->is_decimal;             # false
\&    12.34\->is_decimal;          # true
\&    ".34"\->is_decimal;          # true
.Ve
.PP
\fIReference Related Methods\fR
.IX Subsection "Reference Related Methods"
.PP
The following core functions are implemented.
.PP
tie, tied, ref,
vec.
.PP
\&\f(CW\*(C`tie\*(C'\fR, \f(CW\*(C`tied\*(C'\fR, and \f(CW\*(C`undef\*(C'\fR don't work on code references.
.PP
\fIArray Methods\fR
.IX Subsection "Array Methods"
.PP
Array methods work on both arrays and array references:
.PP
.Vb 2
\&  my $arr = [ 1 .. 10 ];
\&  $arr\->undef;
.Ve
.PP
Or:
.PP
.Vb 2
\&  my @arr = ( 1 .. 10 );
\&  @arr\->undef;
.Ve
.PP
List context forces methods to return a list:
.PP
.Vb 2
\&  my @arr = ( 1 .. 10 );
\&  print join \*(Aq \-\- \*(Aq, @arr\->grep(sub { $_ > 3 }), "\en";
.Ve
.PP
Likewise, scalar context forces methods to return an array reference.
.PP
As scalar context forces methods to return a reference, methods may be chained
.PP
.Vb 2
\&  my @arr = ( 1 .. 10 );
\&  @arr\->grep(sub { $_ > 3 })\->min\->say;  # "4\en";
.Ve
.PP
These built-in functions are defined as methods:
.PP
pop, push, shift,
unshift, delete,
undef, exists,
bless, tie, tied,
ref, grep, map,
join, reverse, and
sort, each.
.PP
As well as:
.PP
vdelete
.IX Subsection "vdelete"
.PP
Deletes a specified value from the array.
.PP
.Vb 3
\&  $a = 1\->to(10);
\&  $a\->vdelete(3);         # deletes 3
\&  $a\->vdelete(2)\->say;    # "1 4 5 6 7 8 9 10\en"
.Ve
.PP
uniq
.IX Subsection "uniq"
.PP
Removes all duplicate elements from an array and returns the new array 
with no duplicates.
.PP
.Vb 2
\&   my @array = qw( 1 1 2 3 3 6 6 );
\&   @return = @array\->uniq;    # @return : 1 2 3 6
.Ve
.PP
first
.IX Subsection "first"
.PP
Returns the first element of an array for which a callback returns true:
.PP
.Vb 1
\&  $arr\->first(sub { qr/5/ });
.Ve
.PP
max
.IX Subsection "max"
.PP
Returns the largest numerical value in the array.
.PP
.Vb 2
\&   $a = 1\->to(10);
\&   $a\->max;           # 10
.Ve
.PP
min
.IX Subsection "min"
.PP
Returns the smallest numerical value in the array.
.PP
.Vb 2
\&   $a = 1\->to(10);
\&   $a\->min;           # 1
.Ve
.PP
mean
.IX Subsection "mean"
.PP
Returns the mean of elements of an array.
.PP
.Vb 2
\&   $a = 1\->to(10);
\&   $a\->mean;          # 55/10
.Ve
.PP
var
.IX Subsection "var"
.PP
Returns the variance of the elements of an array.
.PP
.Vb 2
\&   $a = 1\->to(10);
\&   $a\->var;           # 33/4
.Ve
.PP
svar
.IX Subsection "svar"
.PP
Returns the standard variance.
.PP
.Vb 2
\&  $a = 1\->to(10);
\&  $a\->svar;                     # 55/6
.Ve
.PP
at
.IX Subsection "at"
.PP
Returns the element at a specified index. This function does not modify the
original array.
.PP
.Vb 2
\&   $a = 1\->to(10);
\&   $a\->at(2);                   # 3
.Ve
.PP
size, elems, length
.IX Subsection "size, elems, length"
.PP
\&\f(CW\*(C`size\*(C'\fR, \f(CW\*(C`elems\*(C'\fR and \f(CW\*(C`length\*(C'\fR all return the number of elements in an array.
.PP
.Vb 2
\&   my @array = qw(foo bar baz);
\&   @array\->size;   # 3
.Ve
.PP
elements, flatten
.IX Subsection "elements, flatten"
.PP
.Vb 1
\&    my @copy_of_array = $array\->flatten;
.Ve
.PP
Returns the elements of an array ref as an array.
This is the same as \f(CW\*(C`@{$array}\*(C'\fR.
.PP
Arrays can be iterated on using \f(CW\*(C`for\*(C'\fR and \f(CW\*(C`foreach\*(C'\fR. Both take a code
reference as the body of the for statement.
.PP
foreach
.IX Subsection "foreach"
.PP
.Vb 1
\&    @array\->foreach(\e&code);
.Ve
.PP
Calls \f(CW&code\fR on each element of the \f(CW@array\fR in order.  &code gets the
element as its argument.
.PP
.Vb 1
\&    @array\->foreach(sub { print $_[0] });  # print each element of the array
.Ve
.PP
for
.IX Subsection "for"
.PP
.Vb 1
\&    @array\->for(\e&code);
.Ve
.PP
Like foreach, but \f(CW&code\fR is called with the index, the value and
the array itself.
.PP
.Vb 5
\&    my $arr = [ 1 .. 10 ];
\&    $arr\->for(sub {
\&        my($idx, $value) = @_;
\&        print "Value #$idx is $value\en";
\&    });
.Ve
.PP
sum
.IX Subsection "sum"
.PP
.Vb 1
\&    my $sum = @array\->sum;
.Ve
.PP
Adds together all the elements of the array.
.PP
count
.IX Subsection "count"
.PP
Returns the number of elements in array that are \f(CW\*(C`eq\*(C'\fR to a specified value:
.PP
.Vb 2
\&  my @array = qw/one two two three three three/;
\&  my $num = @array\->count(\*(Aqthree\*(Aq);  # returns 3
.Ve
.PP
to, upto, downto
.IX Subsection "to, upto, downto"
.PP
\&\f(CW\*(C`to\*(C'\fR, \f(CW\*(C`upto\*(C'\fR, and \f(CW\*(C`downto\*(C'\fR create array references:
.PP
.Vb 3
\&   1\->to(5);      # creates [1, 2, 3, 4, 5]
\&   1\->upto(5);    # creates [1, 2, 3, 4, 5]
\&   5\->downto(5);  # creates [5, 4, 3, 2, 1]
.Ve
.PP
Those wrap the \f(CW\*(C`..\*(C'\fR operator.
.PP
\&\fBNote\fR while working with negative numbers you need to use () so as
to avoid the wrong evaluation.
.PP
.Vb 3
\&  my $range = 10\->to(1);        # this works
\&  my $range = \-10\->to(10);      # wrong, interpreted as \-( 10\->to(10) )
\&  my $range = (\-10)\->to(10);    # this works
.Ve
.PP
head
.IX Subsection "head"
.PP
Returns the first element from \f(CW@list\fR.   This differs from
shift in that it does not change the array.
.PP
.Vb 1
\&    my $first = @list\->head;
.Ve
.PP
tail
.IX Subsection "tail"
.PP
Returns all but the first element from \f(CW@list\fR.
.PP
.Vb 2
\&    my @list = qw(foo bar baz quux);
\&    my @rest = @list\->tail;  # [ \*(Aqbar\*(Aq, \*(Aqbaz\*(Aq, \*(Aqquux\*(Aq ]
.Ve
.PP
Optionally, you can pass a number as argument to ask for the last \f(CW$n\fR
elements:
.PP
.Vb 1
\&    @rest = @list\->tail(2); # [ \*(Aqbaz\*(Aq, \*(Aqquux\*(Aq ]
.Ve
.PP
slice
.IX Subsection "slice"
.PP
Returns a list containing the elements from \f(CW@list\fR at the indices
\&\f(CW@indices\fR. In scalar context, returns an array reference.
.PP
.Vb 2
\&    # Return $list[1], $list[2], $list[4] and $list[8].
\&    my @sublist = @list\->slice(1,2,4,8);
.Ve
.PP
range
.IX Subsection "range"
.PP
\&\f(CW\*(C`range\*(C'\fR returns a list containing the elements from \f(CW@list\fR with indices
ranging from \f(CW$lower_idx\fR to \f(CW$upper_idx\fR. It returns an array reference
in scalar context.
.PP
.Vb 1
\&    my @sublist = @list\->range( $lower_idx, $upper_idx );
.Ve
.PP
last_index
.IX Subsection "last_index"
.PP
.Vb 1
\&    my $index = @array\->last_index(qr/.../);
.Ve
.PP
Returns the highest index whose element matches the given regular expression.
.PP
.Vb 1
\&    my $index = @array\->last_index(\e&filter);
.Ve
.PP
Returns the highest index for an element on which the filter returns true.
The &filter is passed in each value of the \f(CW@array\fR.
.PP
.Vb 2
\&    my @things = qw(pear poll potato tomato);
\&    my $last_p = @things\->last_index(qr/^p/); # 2
.Ve
.PP
Called with no arguments, it corresponds to \f(CW$#array\fR giving the
highest index of the array.
.PP
.Vb 1
\&    my $index = @array\->last_index;
.Ve
.PP
first_index
.IX Subsection "first_index"
.PP
Works just like last_index but it will return the index of the \fIfirst\fR
matching element.
.PP
.Vb 1
\&    my $first_index = @array\->first_index;    # 0
\&
\&    my @things = qw(pear poll potato tomato);
\&    my $last_p = @things\->first_index(qr/^t/); # 3
.Ve
.PP
at
.IX Subsection "at"
.PP
.Vb 1
\&    my $value = $array\->at($index);
.Ve
.PP
Equivalent to \f(CW\*(C`$array\->[$index]\*(C'\fR.
.PP
\fIHash Methods\fR
.IX Subsection "Hash Methods"
.PP
Hash methods work on both hashes and hash references.
.PP
The built in functions work as normal:
.PP
delete, exists, keys,
values, bless, tie,
tied, ref, undef,
.PP
at, get
.IX Subsection "at, get"
.PP
.Vb 1
\&    my @values = %hash\->get(@keys);
.Ve
.PP
Returns the \f(CW@values\fR of \f(CW@keys\fR.
.PP
put
.IX Subsection "put"
.PP
.Vb 1
\&    %hash\->put(%other_hash);
.Ve
.PP
Overlays \f(CW%other_hash\fR on top of \f(CW%hash\fR.
.PP
.Vb 2
\&   my $h = {a => 1, b => 2};
\&   $h\->put(b => 99, c => 3);    # (a => 1, b => 99, c => 3)
.Ve
.PP
set
.IX Subsection "set"
.PP
Synonym for put.
.PP
each
.IX Subsection "each"
.PP
Like \f(CW\*(C`foreach\*(C'\fR but for hash references. For each key in the hash, the
code reference is invoked with the key and the corresponding value as
arguments:
.PP
.Vb 2
\&  my $hashref = { foo => 10, bar => 20, baz => 30, quux => 40 };
\&  $hashref\->each(sub { print $_[0], \*(Aq is \*(Aq, $_[1], "\en" });
.Ve
.PP
Or:
.PP
.Vb 2
\&  my %hash = ( foo => 10, bar => 20, baz => 30, quux => 40 );
\&  %hash\->each(sub { print $_[0], \*(Aq is \*(Aq, $_[1], "\en" });
.Ve
.PP
Unlike regular \f(CW\*(C`each\*(C'\fR, this each will always iterate through the entire hash.
.PP
Hash keys appear in random order that varies from run to run (this is
intentional, to avoid calculated attacks designed to trigger
algorithmic worst case scenario in \f(CW\*(C`perl\*(C'\fR's hash tables).
.PP
You can get a sorted \f(CW\*(C`foreach\*(C'\fR by combining \f(CW\*(C`keys\*(C'\fR, \f(CW\*(C`sort\*(C'\fR, and \f(CW\*(C`foreach\*(C'\fR:
.PP
.Vb 3
\&   %hash\->keys\->sort\->foreach(sub {
\&      print $_[0], \*(Aq is \*(Aq, $hash{$_[0]}, "\en";
\&   });
.Ve
.PP
lock_keys
.IX Subsection "lock_keys"
.PP
.Vb 1
\&    %hash\->lock_keys;
.Ve
.PP
Works as \*(L"lock_keys\*(R" in Hash::Util.  No more keys may be added to the hash.
.PP
slice
.IX Subsection "slice"
.PP
Takes a list of hash keys and returns the corresponding values e.g.
.PP
.Vb 5
\&  my %hash = (
\&      one   => \*(Aqtwo\*(Aq,
\&      three => \*(Aqfour\*(Aq,
\&      five  => \*(Aqsix\*(Aq
\&  );
\&
\&  print %hash\->slice(qw(one five))\->join(\*(Aq and \*(Aq); # prints "two and six"
.Ve
.PP
flip
.IX Subsection "flip"
.PP
Exchanges values for keys in a hash:
.PP
.Vb 2
\&    my %things = ( foo => 1, bar => 2, baz => 5 );
\&    my %flipped = %things\->flip; # { 1 => foo, 2 => bar, 5 => baz }
.Ve
.PP
If there is more than one occurence of a certain value, any one of the
keys may end up as the value.  This is because of the random ordering
of hash keys.
.PP
.Vb 2
\&    # Could be { 1 => foo }, { 1 => bar }, or { 1 => baz }
\&    { foo => 1, bar => 1, baz => 1 }\->flip;
.Ve
.PP
Because references cannot usefully be keys, it will not work where the
values are references.
.PP
.Vb 1
\&    { foo => [ \*(Aqbar\*(Aq, \*(Aqbaz\*(Aq ] }\->flip; # dies
.Ve
.PP
flatten
.IX Subsection "flatten"
.PP
.Vb 1
\&    my %hash = $hash_ref\->flatten;
.Ve
.PP
Dereferences a hash reference.
.PP
\fICode Methods\fR
.IX Subsection "Code Methods"
.PP
Methods which work on code references.
.PP
These are simple wrappers around the Perl core functions.
bless, ref,
.PP
Due to Perl's precedence rules, some autoboxed literals may need to be
parenthesized.  For instance, this works:
.PP
.Vb 1
\&  my $curried = sub { ... }\->curry();
.Ve
.PP
This does not:
.PP
.Vb 1
\&  my $curried = \e&foo\->curry();
.Ve
.PP
The solution is to wrap the reference in parentheses:
.PP
.Vb 1
\&  my $curried = (\e&foo)\->curry();
.Ve
.PP
curry
.IX Subsection "curry"
.PP
.Vb 1
\&    my $curried_code = $code\->curry(5);
.Ve
.PP
Currying takes a code reference and provides the same code, but with
the first argument filled in.
.PP
.Vb 5
\&    my $greet_world = sub {
\&        my($greeting, $place) = @_;
\&        return "$greeting, $place!";
\&    };
\&    print $greet_world\->("Hello", "world");  # "Hello, world!"
\&
\&    my $howdy_world = $greet_world\->curry("Howdy");
\&    print $howdy_world\->("Texas");           # "Howdy, Texas!"
.Ve
.SS "What's Missing?"
.IX Subsection "What's Missing?"
.IP "\(bu" 4
File and socket operations are already implemented in an object-oriented
fashion care of IO::Handle, IO::Socket::INET, and IO::Any.
.IP "\(bu" 4
Functions listed in the perlfunc headings
.RS 4
.IP "\(bu" 4
\&\*(L"System V interprocess communication functions\*(R",
.IP "\(bu" 4
\&\*(L"Fetching user and group info\*(R",
.IP "\(bu" 4
\&\*(L"Fetching network info\*(R",
.IP "\(bu" 4
\&\*(L"Keywords related to perl modules\*(R",
.IP "\(bu" 4
\&\*(L"Functions for processes and process groups\*(R",
.IP "\(bu" 4
\&\*(L"Keywords related to scoping\*(R",
.IP "\(bu" 4
\&\*(L"Time-related functions\*(R",
.IP "\(bu" 4
\&\*(L"Keywords related to the control flow of your perl program\*(R",
.IP "\(bu" 4
\&\*(L"Functions for filehandles, files, or directories\*(R",
.IP "\(bu" 4
\&\*(L"Input and output functions\*(R".
.RE
.RS 4
.RE
.IP "\(bu" 4
(Most) binary operators
.PP
These things are likely implemented in an object oriented fashion by other
\&\s-1CPAN\s0 modules, are keywords and not functions, take no arguments, or don't
make sense as part of the string, number, array, hash, or code \s-1API.\s0
.SS "Autoboxing"
.IX Subsection "Autoboxing"
\&\fIThis section quotes four pages from the manuscript of Perl 6 Now: The
Core Ideas Illustrated with Perl 5 by Scott Walters. The text appears in
the book starting at page 248. This copy lacks the benefit of copyedit \-
the finished product is of higher quality.\fR
.PP
A \fIbox\fR is an object that contains a primitive variable.  Boxes are used
to endow primitive types with the capabilities of objects which
essential in strongly typed languages but never strictly required in Perl.
Programmers might write something like \f(CW\*(C`my $number = Int\->new(5)\*(C'\fR.
This is manual boxing.  To \fIautobox\fR is to convert a simple type into an
object type automatically, or only conceptually.  This is done by the language.
.PP
\&\fIautobox\fRing makes a language look to programmers as if everything is an
object while the interpreter is free to implement data storage however it
pleases.  Autoboxing is really making simple types such as numbers,
strings, and arrays appear to be objects.
.PP
\&\f(CW\*(C`int\*(C'\fR, \f(CW\*(C`num\*(C'\fR, \f(CW\*(C`bit\*(C'\fR, \f(CW\*(C`str\*(C'\fR, and other types with lower case names, are
primitives.  They're fast to operate on, and require no more memory to
store than the data held strictly requires.  \f(CW\*(C`Int\*(C'\fR, \f(CW\*(C`Num\*(C'\fR, \f(CW\*(C`Bit\*(C'\fR,
\&\f(CW\*(C`Str\*(C'\fR, and other types with an initial capital letter, are objects.  These
may be subclassed (inherited from) and accept traits, among other things.
These objects are provided by the system for the sole purpose of
representing primitive types as objects, though this has many ancillary
benefits such as making \f(CW\*(C`is\*(C'\fR and \f(CW\*(C`has\*(C'\fR work.  Perl provides \f(CW\*(C`Int\*(C'\fR to
encapsulate an \f(CW\*(C`int\*(C'\fR, \f(CW\*(C`Num\*(C'\fR to encapsulate a \f(CW\*(C`num\*(C'\fR, \f(CW\*(C`Bit\*(C'\fR to
encapsulate a \f(CW\*(C`bit\*(C'\fR, and so on.  As Perl's implementations of hashes and
dynamically expandable arrays store any type, not just objects, Perl
programmers almost never are required to box primitive types in objects.
Perl's power makes this feature less essential than it is in other
languages.
.PP
\&\fIautobox\fRing makes primitive objects and they're boxed versions
equivalent.  An \f(CW\*(C`int\*(C'\fR may be used as an \f(CW\*(C`Int\*(C'\fR with no constructor call,
no passing, nothing.  This applies to constants too, not just variables.
This is a more Perl 6 way of doing things.
.PP
.Vb 1
\&  # Perl 6 \- autoboxing associates classes with primitives types:
\& 
\&  print 4.sqrt, "\en";
\&
\&  print [ 1 .. 20 ].elems, "\en";
.Ve
.PP
The language is free to implement data storage however it wishes but the
programmer sees the variables as objects.
.PP
Expressions using autoboxing read somewhat like Latin suffixes.  In the
autoboxing mind-set, you might not say that something is \*(L"made more
mnemonic\*(R", but has been \*(L"mnemonicified\*(R".
.PP
Autoboxing may be mixed with normal function calls.
In the case where the methods are available as functions and the functions are
available as methods, it is only a matter of personal taste how the expression should be written:
.PP
.Vb 2
\&  # Calling methods on numbers and strings, these three lines are equivalent
\&  # Perl 6
\&
\&  print sqrt 4;
\&  print 4.sqrt;
\&  4.sqrt.print;
.Ve
.PP
The first of these three equivalents assumes that a global \f(CW\*(C`sqrt()\*(C'\fR
function exists.  This first example would fail to operate if this global
function were removed and only a method in the \f(CW\*(C`Num\*(C'\fR package was left.
.PP
Perl 5 had the beginnings of autoboxing with filehandles:
.PP
.Vb 3
\&  use IO::Handle;
\&  open my $file, \*(Aq<\*(Aq, \*(Aqfile.txt\*(Aq or die $!;
\&  $file\->read(my $data, \-s $file);
.Ve
.PP
Here, \f(CW\*(C`read\*(C'\fR is a method on a filehandle we opened but \fInever blessed\fR.
This lets us say things like \f(CW\*(C`$file\->print(...)\*(C'\fR rather than the often
ambagious \f(CW\*(C`print $file ...\*(C'\fR.
.PP
To many people, much of the time, it makes more conceptual sense as well.
.PP
\fIReasons to Box Primitive Types\fR
.IX Subsection "Reasons to Box Primitive Types"
.PP
What good is all of this?
.IP "\(bu" 4
Makes conceptual sense to programmers used to object interfaces as \fIthe\fR way
to perform options.
.IP "\(bu" 4
Alternative idiom. Doesn't require the programmer to write or read
expressions with complex precedence rules or strange operators.
.IP "\(bu" 4
Many times that parenthesis would otherwise have to span a large
expression, the expression may be rewritten such that the parenthesis span
only a few primitive types.
.IP "\(bu" 4
Code may often be written with fewer temporary variables.
.IP "\(bu" 4
Autoboxing provides the benefits of boxed types without the memory bloat of
actually using objects to represent primitives. Autoboxing \*(L"fakes it\*(R".
.IP "\(bu" 4
Strings, numbers, arrays, hashes, and so on, each have their own \s-1API.\s0
Documentation for an \f(CW\*(C`exists\*(C'\fR method for arrays doesn't have to explain
how hashes are handled and vice versa.
.IP "\(bu" 4
Perl tries to accommodate the notion that the \*(L"subject\*(R" of a statement
should be the first thing on the line, and autoboxing furthers this agenda.
.PP
Perl is an idiomatic language and this is an important idiom.
.PP
\fISubject First: An Aside\fR
.IX Subsection "Subject First: An Aside"
.PP
Perl's design philosophy promotes the idea that the language should be
flexible enough to allow programmers to place the subject of a statement
first.  For example, \f(CW\*(C`die $! unless read $file, 60\*(C'\fR looks like the
primary purpose of the statement is to \f(CW\*(C`die\*(C'\fR.
.PP
While that might be the programmers primary goal, when it isn't, the
programmer can communicate his real primary intention to programmers by
reversing the order of clauses while keeping the exact same logic: \f(CW\*(C`read
$file, 60 or die $!\*(C'\fR.
.PP
Autoboxing is another way of putting the subject first.
.PP
Nouns make good subjects, and in programming, variables, constants, and
object names are the nouns.  Function and method names are verbs.  \f(CW\*(C`$noun\->verb()\*(C'\fR focuses the readers attention on the thing being acted on
rather than the action being performed.  Compare to \f(CW\*(C`$verb($noun)\*(C'\fR.
.PP
\fIAutoboxing and Method Results\fR
.IX Subsection "Autoboxing and Method Results"
.PP
Let's look at some examples of ways an expression could be
written.
.PP
.Vb 1
\&  # Various ways to do the same thing:
\&
\&  print(reverse(sort(keys(%hash))));          # Perl 5 \- pathological parenthetic
\&  print reverse sort keys %hash;              # Perl 5 \- no unneeded parenthesis
\&
\&  print(reverse(sort(%hash,keys))));          # Perl 6 \- pathological
\&  print reverse sort %hash.keys;              # Perl 6 \- no unneeded parenthesis
\&
\&  %hash.keys ==> sort ==> reverse ==> print;  # Perl 6 \- pipeline operator
\&
\&  %hash.keys.sort.reverse.print;              # Perl 6 \- autobox
\&
\&  %hash\->keys\->sort\->reverse\->print;          # Perl 5 \- autobox
.Ve
.PP
This section deals with the last two of these equivalents.
These are method calls
.PP
.Vb 2
\&  use autobox::Core;
\&  use Perl6::Contexts;
\&
\&  my %hash = (foo => \*(Aqbar\*(Aq, baz => \*(Aqquux\*(Aq);
\&
\&  %hash\->keys\->sort\->reverse\->print;          # Perl 5 \- autobox
\&
\&  # prints "foo baz"
.Ve
.PP
Each method call returns an array reference, in this example.  Another
method call is immediately performed on this value.  This feeding of the
next method call with the result of the previous call is the common mode of
use of autoboxing.  Providing no other arguments to the method calls,
however, is not common.
.PP
\&\f(CW\*(C`Perl6::Contexts\*(C'\fR recognizes object context as provided by \f(CW\*(C`\->\*(C'\fR and
coerces \f(CW%hash\fR and \f(CW@array\fR into references, suitable for use with
\&\f(CW\*(C`autobox\*(C'\fR.  (Note that \f(CW\*(C`autobox\*(C'\fR also does this automatically as of
version 2.40.)
.PP
\&\f(CW\*(C`autobox\*(C'\fR associates primitive types, such as references of various sorts,
with classes.  \f(CW\*(C`autobox::Core\*(C'\fR throws into those classes methods wrapping
Perl's built-in functions.  In the interest of full disclosure,
\&\f(CW\*(C`Perl6::Contexts\*(C'\fR and \f(CW\*(C`autobox::Core\*(C'\fR are my creations.
.PP
\fIAutobox to Simplify Expressions\fR
.IX Subsection "Autobox to Simplify Expressions"
.PP
One of my pet peeves in programming is parenthesis that span large
expression.  It seems like about the time I'm getting ready to close the
parenthesis I opened on the other side of the line, I realize that I've
forgotten something, and I have to arrow back over or grab the mouse.
.PP
When the expression is too long to fit on a single line, it gets broken up,
then I must decide how to indent it if it grows to 3 or more lines.
.PP
.Vb 1
\&  # Perl 5 \- a somewhat complex expression
\&
\&  print join("\en", map { CGI::param($_) } @cgi_vars), "\en";
\&  # Perl 5 \- again, using autobox:
\&
\&  @cgi_vars\->map(sub { CGI::param($_[0]) })\->join("\en")\->concat("\en")\->print;
.Ve
.PP
The autoboxed version isn't shorter, but it reads from left to right, and
the parenthesis from the \f(CW\*(C`join()\*(C'\fR don't span nearly as many characters.
The complex expression serving as the value being \f(CW\*(C`join()\*(C'\fRed in the
non-autoboxed version becomes, in the autoboxed version, a value to call
the \f(CW\*(C`join()\*(C'\fR method on.
.PP
This \f(CW\*(C`print\*(C'\fR statement takes a list of \s-1CGI\s0 parameter names, reads the
values for each parameter, joins them together with newlines, and prints
them with a newline after the last one.
.PP
Pretending that this expression were much larger and it had to be broken to span
several lines, or pretending that comments are to be placed after each part of
the expression, you might reformat it as such:
.PP
.Vb 4
\&  @cgi_vars\->map(sub { CGI::param($_[0]) })  # turn CGI arg names into values
\&           \->join("\en")                      # join with newlines
\&           \->concat("\en")                    # give it a trailing newline
\&           \->print;                          # print them all out
.Ve
.PP
\&\fIHere ends the text quoted from the Perl 6 Now manuscript.\fR
.SH "BUGS"
.IX Header "BUGS"
Yes. Report them to the author, scott@slowass.net, or post them to
GitHub's bug tracker at <https://github.com/scrottie/autobox\-Core/issues>.
.PP
The \s-1API\s0 is not yet stable \*(-- Perl 6\-ish things and local extensions are
still being renamed.
.SH "HISTORY"
.IX Header "HISTORY"
See the Changes file.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2009, 2010, 2011 by Scott Walters and various contributors listed (and unlisted) below.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.9 or,
at your option, any later version of Perl 5 you may have available.
.PP
This library is distributed in the hope that it will be useful, but without
any warranty; without even the implied warranty of merchantability or fitness
for a particular purpose.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "autobox" 1
.IX Item "autobox"
.PD 0
.IP "Moose::Autobox" 1
.IX Item "Moose::Autobox"
.IP "Perl6::Contexts" 1
.IX Item "Perl6::Contexts"
.IP "<http://github.com/gitpan/autobox\-Core>" 1
.IX Item "<http://github.com/gitpan/autobox-Core>"
.IP "IO::Any" 1
.IX Item "IO::Any"
.IP "Perl 6: <http://dev.perl.org/perl6/apocalypse/>." 1
.IX Item "Perl 6: <http://dev.perl.org/perl6/apocalypse/>."
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Scott Walters, scott@slowass.net.
.PP
Michael Schwern and the perl5i contributors for tests, code, and feedback.
.PP
\&\s-1JJ\s0 contributed a \f(CW\*(C`strip\*(C'\fR method for scalars \- thanks \s-1JJ\s0!
.PP
Ricardo \s-1SIGNES\s0 contributed patches.
.PP
Thanks to Matt Spear, who contributed tests and definitions for numeric operations.
.PP
Mitchell N Charity reported a bug and sent a fix.
.PP
Thanks to chocolateboy for autobox and for the encouragement.
.PP
Thanks to Bruno Vecchi for bug fixes and many, many new tests going into version 0.8.
.PP
Thanks to <http://github.com/daxim> daxim/Lars \s-1DIECKOW\s0 pushing in fixes and patches from the \s-1RT\s0 queue
along with fixes to build and additional doc examples.
.PP
Jacinta Richardson improved documentation.
